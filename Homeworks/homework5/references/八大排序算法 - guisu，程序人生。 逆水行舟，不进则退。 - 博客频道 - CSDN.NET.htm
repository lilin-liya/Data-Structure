<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!-- saved from url=(0051)http://blog.csdn.net/hguisu/article/details/7776068 -->
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <script type="text/javascript" async="" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/ga.js"></script><script id="allmobilize" charset="utf-8" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/allmobilize.min.js"></script><style type="text/css"></style>
 <meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" media="handheld" href="http://blog.csdn.net/hguisu/article/details/7776068#">

    <title>八大排序算法 - guisu，程序人生。  逆水行舟，不进则退。
        - 博客频道 - CSDN.NET</title>
    
    <meta name="description" content="概述排序有内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。我们这里说说八大排序就是内部排序。         当n较大，则应采用时间复杂度为O(nlog2n)的排序方法：快速排序、堆排序或归并排序序。   快速排序：是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键">
    <script src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/jquery.js" type="text/javascript"></script>
    <script type="text/javascript" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/ad.js"></script>
        <!--new top-->
       
        <link rel="stylesheet" href="http://static.csdn.net/public/common/toolbar/css/index.css">
        <!--new top-->

    <link rel="Stylesheet" type="text/css" href="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/style.css">
    <link id="RSSLink" title="RSS" type="application/rss+xml" rel="alternate" href="http://blog.csdn.net/hguisu/rss/list">
    <link rel="shortcut icon" href="http://csdnimg.cn/public/favicon.ico">
    <link type="text/css" rel="stylesheet" href="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/simple.css">
 


<script src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/share.js"></script><link href="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/bdsstyle.css" rel="stylesheet" type="text/css"><script type="text/javascript" charset="utf-8" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/tracking.js"></script><script type="text/javascript" charset="utf-8" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/main.js"></script><link rel="stylesheet" type="text/css" href="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/style(1).css"><link type="text/css" rel="stylesheet" href="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/style(2).css"><script src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/logger.js"></script><link rel="stylesheet" href="http://bdimg.share.baidu.com/static/api/css/share_style0_16.css?v=f4b44e79.css"></head>
<body><iframe frameborder="0" style="display: none;"></iframe>
    
   
      <!--new top-->
    <script id="toolbar-tpl-scriptId" fixed="true" prod="blog" skin="black" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/html.js" type="text/javascript"></script><div class="csdn-toolbar csdn-toolbar-skin-black ">        <div class="container row center-block ">          <div class="col-md-3 pull-left logo clearfix"><a href="http://www.csdn.net/?ref=toolbar" title="CSDN首页" target="_blank" class="icon"></a><a title="频道首页" href="http://blog.csdn.net/?ref=toolbar_logo" target="_blank" class="img blog-icon"></a></div>          <div class="pull-right login-wrap unlogin">            <ul class="btns">              <li class="loginlink"><a href="https://passport.csdn.net/account/login?ref=toolbar" target="_top">登录&nbsp;</a>|<a target="_top" href="https://passport.csdn.net/account/register?ref=toolbar">&nbsp;注册</a></li>              <li class="search">                <div class="icon on-search-icon">                  <div class="wrap">                    <div class="curr-icon-wrap">                      <div class="curr-icon"></div>                    </div>                    <form action="http://so.csdn.net/search" method="get" target="_blank">                      <input type="hidden" value="toolbar" name="ref" accesskey="2">                      <div class="border">                        <input placeholder="搜索" type="text" value="" name="q" accesskey="2"><span class="icon-enter-sm"></span>                      </div>                    </form>                  </div>                </div>              </li>              <li class="favor">                <div class="icon on-favor-icon">                  <div class="wrap">                    <div class="curr-icon-wrap">                      <div class="curr-icon"></div>                    </div>                    <div style="display:none;" class="favor-success"><span class="msg">收藏成功</span>                      <div class="btns"><span class="btn btn-primary ok">确定</span></div>                    </div>                    <div style="display:none;" class="favor-failed"><span class="icon-danger-lg"></span><span class="msg">收藏失败，请重新收藏</span>                      <div class="btns"><span class="btn btn-primary ok">确定</span></div>                    </div>                    <form role="form" class="form-horizontal favor-form">                      <div class="form-group">                        <div class="clearfix">                          <label for="input-title" class="col-sm-2 control-label">标题</label>                          <div class="col-sm-10">                            <input id="inputTitle" type="text" placeholder="" class="title form-control">                          </div>                        </div>                        <div class="alert alert-danger"><strong></strong>标题不能为空</div>                      </div>                      <div class="form-group">                        <label for="input-url" class="col-sm-2 control-label">网址</label>                        <div class="col-sm-10">                          <input id="input-url" type="text" placeholder="" class="url form-control">                        </div>                      </div>                      <div class="form-group">                        <label for="input-tag" class="col-sm-2 tag control-label">标签</label>                        <div class="col-sm-10">                          <input id="input-tag" type="text" class="form-control tag">                        </div>                      </div>                      <div class="form-group">                        <label for="input-description" class="description col-sm-2 control-label">摘要</label>                        <div class="col-sm-10">                          <textarea id="input-description" class="form-control description"></textarea>                        </div>                      </div>                      <div class="form-group">                        <div class="col-sm-offset-2 col-sm-10 ft">                          <div class="col-sm-4 pull-left">                            <div class="checkbox">                              <label>                                <input type="checkbox" name="share" checked="checked" class="share">公开                              </label>                            </div>                          </div>                          <div class="col-sm-8 pull-right favor-btns">                            <button type="button" class="cancel btn btn-default">取消</button>                            <button type="submit" class="submit btn btn-primary">收藏</button>                          </div>                        </div>                      </div>                    </form>                  </div>                </div>              </li>              <li class="notify">                <div style="display:none" class="number"></div>                <div style="display:none" class="icon-hasnotes-sm"></div>                <div id="header_notice_num"></div>                <div class="icon on-notify-icon">                  <div class="wrap">                    <div class="curr-icon-wrap">                      <div class="curr-icon"></div>                    </div>                    <div id="note1" class="csdn_note">                      <div class="box"></div>                    <iframe src="about:block" frameborder="0" allowtransparency="true" style="z-index:-1;position:absolute;top:0;left:0;width:100%;height:100%;background:transparent"></iframe></div>                  </div>                </div>              </li>              <li class="ugc">                <div class="icon on-ugc-icon">                  <div class="wrap clearfix">                    <div class="curr-icon-wrap">                      <div class="curr-icon"></div>                    </div>                    <dl>                      <dt><a href="http://geek.csdn.net/news/expert?ref=toolbar" target="_blank" class="p-news clearfix"><em class="icon"></em><span>分享资讯</span></a></dt>                      <dt><a href="http://share.csdn.net/slides/new?ref=toolbar" target="_blank" class="p-doc clearfix"><em class="icon"></em><span>传PPT/文档</span></a></dt>                      <dt><a href="http://bbs.csdn.net/topics/new?ref=toolbar" target="_blank" class="p-ask clearfix"><em class="icon"></em><span>提问题</span></a></dt>                      <dt><a href="http://write.blog.csdn.net/postedit?ref=toolbar" target="_blank" class="p-blog clearfix"><em class="icon"></em><span>写博客</span></a></dt>                      <dt><a href="http://u.download.csdn.net/upload?ref=toolbar" target="_blank" class="p-src clearfix"><em class="icon"></em><span>传资源</span></a></dt>                      <dt><a href="https://code.csdn.net/projects/new?ref=toolbar" target="_blank" class="c-obj clearfix"><em class="icon"></em><span>创建项目</span></a></dt>                      <dt><a href="https://code.csdn.net/snippets/new?ref=toolbar" target="_blank" class="c-code clearfix"><em class="icon"></em><span>创建代码片</span></a></dt>                    </dl>                  </div>                </div>              </li>              <li class="profile">                <div class="icon on-profile-icon"><img src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/100x100.jpg" class="curr-icon-img">                  <div class="wrap clearfix">                    <div class="curr-icon-wrap">                      <div class="curr-icon"></div>                    </div>                    <div class="bd">                      <dl class="clearfix">                        <dt class="pull-left img"><a target="_blank" href="http://my.csdn.net/?ref=toolbar" class="avatar"><img src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/100x100.jpg"></a></dt>                        <dd class="info"><a target="_blank" href="http://my.csdn.net/?ref=toolbar" class="nickname"></a><a class="set-nick" href="https://passport.csdn.net/account/profile">设置昵称<span class="write-icon"></span></a><span class="dec"><a class="fill-dec" href="http://my.csdn.net/" target="_blank">编辑自我介绍，让更多人了解你<span class="write-icon"></span></a></span></dd>                      </dl>                    </div>                    <div class="ft clearfix"><a target="_blank" href="http://my.csdn.net/my/account/changepwd?ref=toolbar" class="pull-left"><span class="icon-cog"></span>帐号设置</a><a href="https://passport.csdn.net/account/logout?ref=toolbar" target="_top" class="pull-right "><span class="icon-signout"></span><span class="out">退出</span></a></div>                  </div>                </div>              </li>              <li class="apps">                <div class="icon on-apps-icon">                  <div class="wrap clearfix">                    <div class="curr-icon-wrap">                      <div class="curr-icon"></div>                    </div>                  <div class="detail">                    <dl>                      <dt>                        <h5>社区</h5>                      </dt>                      <dd> <a href="http://blog.csdn.net/?ref=toolbar" target="_blank">博客</a></dd>                      <dd> <a href="http://bbs.csdn.net/?ref=toolbar" target="_blank">论坛</a></dd>                      <dd> <a href="http://download.csdn.net/?ref=toolbar" target="_blank">下载</a></dd>                      <dd><a href="http://share.csdn.net/?ref=toolbar" target="_blank">Share</a></dd>                      <dd><a href="http://geek.csdn.net/?ref=toolbar" target="_blank">极客头条</a></dd>                    </dl>                  </div>                  <div class="detail">                    <dl>                      <dt>                        <h5>服务</h5>                      </dt>                      <dd> <a href="https://code.csdn.net/?ref=toolbar" target="_blank">CODE</a></dd>                      <dd> <a href="http://hero.csdn.net/?ref=toolbar" target="_blank">英雄会</a></dd>                      <dd> <a href="http://huiyi.csdn.net/?ref=toolbar" target="_blank">活动</a></dd>                      <dd> <a href="http://www.csto.com/?ref=toolbar" target="_blank">CSTO</a></dd>                    </dl>                  </div>                  <div class="detail last">                    <dl>                      <dt>                        <h5>俱乐部</h5>                      </dt>                      <dd> <a href="http://cto.csdn.net/?ref=toolbar" target="_blank">CTO俱乐部</a></dd>                      <dd> <a href="http://student.csdn.net/?ref=toolbar" target="_blank">高校俱乐部</a></dd>                    </dl>                  </div>                </div>              </div>            </li>            </ul>          </div>        </div>    </div>
     <!--new top-->
    <div id="container">
        <div id="header">
    <div class="header">
        <div id="blog_title">
            <h2>
                <a href="http://blog.csdn.net/hguisu">guisu，程序人生。  逆水行舟，不进则退。</a></h2>
            <h3>能干的人解决问题。智慧的人绕开问题(A clever person solves a problem. A wise person avoids it)</h3>
            <div class="clear">
            </div>
        </div>
        <div class="clear">
        </div>
    </div>
</div>
<div id="navigator">
    <div class="navigator_bg">
    </div>
    <div class="navigator">
        <ul>
                <li id="btnContents"><a href="http://blog.csdn.net/hguisu?viewmode=contents"><span onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_mulu&#39;])">
                    <img src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/ico_list.gif">目录视图</span></a></li>
                <li id="btnView"><a href="http://blog.csdn.net/hguisu?viewmode=list"><span onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_zhaiyao&#39;])">
                    <img src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/ico_summary.gif">摘要视图</span></a></li>
                <li id="btnRss"><a href="http://blog.csdn.net/hguisu/rss/list"><span onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_RSS&#39;])">
                    <img src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/ico_rss.gif">订阅</span></a></li>                

            </ul>
    </div>
</div>
<script type="text/javascript">
    var username = "hguisu";
    var _blogger = username;
    var blog_address = "http://blog.csdn.net/hguisu";
    var static_host = "http://static.blog.csdn.net";
    var currentUserName = "";  
</script>

        <div id="body">
            <div id="main">
                <div class="main">
                        <div class="ad_class">
<div class="notice tracking-ad" data-mod="popu_3"> 

<a href="http://bbs.csdn.net/topics/390812950?page=2#post-398116601" target="_blank">
<font color="blue">博客专家福利
</font></a>
&nbsp;&nbsp;&nbsp;

<a href="http://www.csdn.net/article/2014-10-13/2822071" target="_blank">
<font color="red">专访徐宜生：坚决不做代码搬运工</font></a>

&nbsp;&nbsp;&nbsp;&nbsp;

<a href="http://blog.csdn.net/blogdevteam/article/details/40047403" target="_blank">
<font color="blue">有奖试读&amp;征文:我们在互联网上奋斗的故事
</font></a>
&nbsp;&nbsp;&nbsp;&nbsp;

<a href="http://weixin2014-sz.csdn.net/" target="_blank">
<font color="red">微信开发者大会深圳站即将开幕
</font></a>


</div>                        </div>
                        

  
<link href="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/comment1.css" type="text/css" rel="stylesheet">
<link href="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/style1.css" type="text/css" rel="stylesheet">
<script language="JavaScript" type="text/javascript" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/jquery.cookie.js"></script>
<script type="text/javascript" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/main(1).js"></script>
<div id="article_details" class="details">
    <div class="article_title">   
         <span class="ico ico_type_Original"></span>


    <h1>
        <span class="link_title"><a href="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET.htm">
        八大排序算法
        </a></span>
    </h1>
</div>

    <div class="article_manage">
        <span class="link_categories">
        分类：
            <a href="http://blog.csdn.net/hguisu/article/category/1054628" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_fenlei&#39;]);">数据结构与算法</a> 
            <a href="http://blog.csdn.net/hguisu/article/category/1080443" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_fenlei&#39;]);">c/c++</a> 
        </span>
    <span class="link_postdate">2012-07-23 16:45</span>
    <span class="link_view" title="阅读次数">36888人阅读</span>
    <span class="link_comments" title="评论次数"><a href="http://blog.csdn.net/hguisu/article/details/7776068#comments" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_pinglun&#39;])">评论</a>(23)</span>
    <span class="link_collect"><a href="javascript:void(0);" onclick="javascript:_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_shoucang&#39;]);collectArticle(&#39;八大排序算法&#39;,&#39;7776068&#39;);return false;" title="收藏">收藏</a></span>
    <span class="link_report"><a href="http://blog.csdn.net/hguisu/article/details/7776068#report" onclick="javascript:_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_jubao&#39;]);report(7776068,2);return false;" title="举报">举报</a></span>
    
</div>
<div class="tag2box"><a href="http://www.csdn.net/tag/%e7%ae%97%e6%b3%95" target="_blank" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_tag&#39;]);">算法</a><a href="http://www.csdn.net/tag/merge" target="_blank" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_tag&#39;]);">merge</a><a href="http://www.csdn.net/tag/pivot" target="_blank" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_tag&#39;]);">pivot</a><a href="http://www.csdn.net/tag/%e5%ad%98%e5%82%a8" target="_blank" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_tag&#39;]);">存储</a><a href="http://www.csdn.net/tag/exchange" target="_blank" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_tag&#39;]);">exchange</a></div>

  
    
<div style="clear:both"></div><div style="border:solid 1px #ccc; background:#eee; float:left; min-width:200px;padding:4px 10px;"><p style="text-align:right;margin:0;"><span style="float:left;">目录<a href="http://blog.csdn.net/hguisu/article/details/7776068#" title="系统根据文章中H1到H6标签自动生成文章目录">(?)</a></span><a href="http://blog.csdn.net/hguisu/article/details/7776068#" onclick="javascript:return openct(this);" title="展开">[+]</a></p><ol style="display:none;margin-left:14px;padding-left:14px;line-height:160%;"><li><a href="http://blog.csdn.net/hguisu/article/details/7776068#t0">概述</a></li><li><a href="http://blog.csdn.net/hguisu/article/details/7776068#t1">插入排序直接插入排序Straight Insertion Sort
</a></li><li><a href="http://blog.csdn.net/hguisu/article/details/7776068#t2">插入排序希尔排序Shells Sort
</a></li><li><a href="http://blog.csdn.net/hguisu/article/details/7776068#t3">选择排序简单选择排序Simple Selection Sort</a></li><li><a href="http://blog.csdn.net/hguisu/article/details/7776068#t4">选择排序堆排序Heap Sort
</a></li><li><a href="http://blog.csdn.net/hguisu/article/details/7776068#t5">交换排序冒泡排序Bubble Sort</a></li><li><a href="http://blog.csdn.net/hguisu/article/details/7776068#t6">交换排序快速排序Quick Sort</a></li><li><a href="http://blog.csdn.net/hguisu/article/details/7776068#t7">归并排序Merge Sort
</a></li><li><a href="http://blog.csdn.net/hguisu/article/details/7776068#t8">桶排序基数排序Radix Sort</a></li><li><a href="http://blog.csdn.net/hguisu/article/details/7776068#t9">总结
</a></li></ol></div><div style="clear:both"></div><div id="article_content" class="article_content">

<h2 class="headline-1 bk-sidecatalog-title" style="border-bottom:rgb(222,223,225) 1px solid; text-align:left; padding-bottom:6px; line-height:26px; margin:0px 0px 10px; padding-left:0px; padding-right:0px; font-family:Arial; color:rgb(51,51,51); clear:both; padding-top:0px"><a name="t0"></a>
<span style="color:#336699"><span style="line-height:36px; font-size:21px">概述</span></span></h2>
排序有内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。
<p><span style="font-family:Tahoma,Verdana,STHeiTi,simsun,sans-serif; font-size:14px; color:#333333; line-height:19px; widows:2; text-transform:none; background-color:rgb(255,255,255); font-variant:normal; font-style:normal; text-indent:0px; display:inline!important; white-space:normal; orphans:2; float:none; letter-spacing:normal; font-weight:normal; word-spacing:0px">我们这里说说八大排序就是内部排序。<br>
</span></p>
<p><img alt="" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/1342514529_5795.jpg"><br>
</p>
<span></span><span>&nbsp;&nbsp;&nbsp;&nbsp; </span>
<p><span style="font-family:Tahoma,Verdana,STHeiTi,simsun,sans-serif; font-size:14px; color:#333333; line-height:19px; widows:2; text-transform:none; background-color:rgb(255,255,255); font-variant:normal; font-style:normal; text-indent:0px; display:inline!important; white-space:normal; orphans:2; float:none; letter-spacing:normal; font-weight:normal; word-spacing:0px">&nbsp;&nbsp;&nbsp;&nbsp;当n较大，<span style="font-size:12px"><span style="font-family:宋体">则应采用时间复杂度为</span><span lang="EN"><span style="font-family:Times New Roman">O(nlog2n)</span></span></span><span style="font-family:Times New Roman"><span style="font-family:宋体; font-size:12px">的排序方法：快速排序、<a target="_blank" style="color: #0000F0; display:inline; position:static; background:none;" href="http://www.so.com/s?q=%E5%A0%86%E6%8E%92%E5%BA%8F&ie=utf-8&src=se_lighten_f">堆排序</a>或归并排序序。</span></span></span></p>
<p><span style="color:#ff0000"><span style="font-family:宋体; font-size:12px">&nbsp;&nbsp; 快速排序：是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；</span><br>
</span></p>
<p><br>
&nbsp;</p>
<h2 class="headline-1 bk-sidecatalog-title" style="border-bottom:rgb(222,223,225) 1px solid; text-align:left; padding-bottom:6px; line-height:26px; margin:0px 0px 10px; padding-left:0px; padding-right:0px; font-family:Arial; color:rgb(51,51,51); clear:both; padding-top:0px"><a name="t1"></a>
<span style="color:#336699"><span style="line-height:36px; font-size:21px">1.插入排序—直接插入排序(Straight Insertion Sort)<br>
</span></span></h2>
<p><span style="color:#3333ff; font-size:16px"><strong>基本思想:</strong></span></p>
<p>将一个记录插入到已排序好的有序表中，从而得到一个新，记录数增1的有序表。即：先将序列的第1个记录看成是一个有序的子序列，然后从第2个记录逐个进行插入，直至整个序列有序为止。<br>
</p>
<p>要点：设立哨兵，作为临时存储和判断数组边界之用。</p>
<p>直接插入排序示例：<br>
</p>
<img alt="" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/1342520948_8667.jpg"><br>
<p><span><br>
</span></p>
<p><span>如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，<strong><span style="color:#ff0000">所以插入排序是稳定的。</span></strong></span></p>
<p><span style="color:#3333ff; font-size:16px"><strong>算法的实现：<br>
</strong></span></p>
<div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><div style="position: absolute; left: 0px; top: 0px; width: 0px; height: 0px; z-index: 99;"><embed id="ZeroClipboardMovie_1" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="0" height="0" name="ZeroClipboardMovie_1" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=1&amp;width=0&amp;height=0" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">void</span><span>&nbsp;print(</span><span class="datatypes">int</span><span>&nbsp;a[],&nbsp;</span><span class="datatypes">int</span><span>&nbsp;n&nbsp;,</span><span class="datatypes">int</span><span>&nbsp;i){&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;i&nbsp;&lt;&lt;<span class="string">":"</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>(</span><span class="datatypes">int</span><span>&nbsp;j=&nbsp;0;&nbsp;j&lt;8;&nbsp;j++){&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;a[j]&nbsp;&lt;&lt;<span class="string">"&nbsp;"</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;endl;&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span><span class="keyword">void</span><span>&nbsp;InsertSort(</span><span class="datatypes">int</span><span>&nbsp;a[],&nbsp;</span><span class="datatypes">int</span><span>&nbsp;n)&nbsp;&nbsp;</span></span></li><li class="alt"><span>{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>(</span><span class="datatypes">int</span><span>&nbsp;i=&nbsp;1;&nbsp;i&lt;n;&nbsp;i++){&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>(a[i]&nbsp;&lt;&nbsp;a[i-1]){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//若第i个元素大于i-1元素，直接插入。小于的话，移动有序表后插入</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;j=&nbsp;i-1;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;x&nbsp;=&nbsp;a[i];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//复制为哨兵，即存储待排序元素</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a[i]&nbsp;=&nbsp;a[i-1];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//先后移一个元素</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span><span>(x&nbsp;&lt;&nbsp;a[j]){&nbsp;&nbsp;</span><span class="comment">//查找在有序表的插入位置</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a[j+1]&nbsp;=&nbsp;a[j];&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j--;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//元素后移</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a[j+1]&nbsp;=&nbsp;x;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//插入到正确位置</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(a,n,i);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//打印每趟排序的结果</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span><span class="datatypes">int</span><span>&nbsp;main(){&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;a[8]&nbsp;=&nbsp;{3,1,5,7,2,4,9,6};&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;InsertSort(a,8);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;print(a,8,8);&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre class="cpp" name="code" style="display: none;">void print(int a[], int n ,int i){
	cout&lt;&lt;i &lt;&lt;":";
	for(int j= 0; j&lt;8; j++){
		cout&lt;&lt;a[j] &lt;&lt;" ";
	}
	cout&lt;&lt;endl;
}


void InsertSort(int a[], int n)
{
	for(int i= 1; i&lt;n; i++){
		if(a[i] &lt; a[i-1]){               //若第i个元素大于i-1元素，直接插入。小于的话，移动有序表后插入
			int j= i-1;	
			int x = a[i];		 //复制为哨兵，即存储待排序元素
			a[i] = a[i-1];           //先后移一个元素
			while(x &lt; a[j]){	 //查找在有序表的插入位置
				a[j+1] = a[j];
				j--;		 //元素后移
			}
			a[j+1] = x;		 //插入到正确位置
		}
		print(a,n,i);			//打印每趟排序的结果
	}
	
}

int main(){
	int a[8] = {3,1,5,7,2,4,9,6};
	InsertSort(a,8);
	print(a,8,8);
}
</pre>
<span style="color:#3333ff; font-size:16px"><strong><br>
</strong></span>
<p><span style="color:#3333ff; font-size:16px"><strong>效率：</strong></span></p>
<p>时间复杂度：O（n^2）.</p>
<p><span style="color:#009900">其他的插入排序有二分插入排序，2-路插入排序。</span></p>
<p>&nbsp;</p>
<h2 class="headline-1 bk-sidecatalog-title" style="border-bottom:rgb(222,223,225) 1px solid; text-align:left; padding-bottom:6px; line-height:26px; margin:0px 0px 10px; padding-left:0px; padding-right:0px; font-family:Arial; color:rgb(51,51,51); clear:both; padding-top:0px"><a name="t2"></a>
<span style="color:#336699"><span style="line-height:36px; font-size:21px">&nbsp;2. 插入排序—希尔排序（Shell`s Sort）<br>
</span></span></h2>
<p>希尔排序是1959 年由D.L.Shell 提出来的，相对直接排序有较大的改进。希尔排序又叫<span style="color:#009900"><strong>缩小增量排序</strong></span></p>
<p><strong><span style="color:#3333ff; font-size:16px">基本思想：</span></strong></p>
<p><span style="font-size:12px">先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</span></p>
<p><span style="font-size:12px"><span style="color:#3333ff"><strong>操作方法：</strong></span><br>
</span></p>
<ol>
<li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1； </li><li>按增量序列个数k，对序列进行k 趟排序； </li><li>每趟排序，根据对应的<span style="font-size:12px">增量</span>ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅<span style="font-size:12px">增量</span>因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ol>
<p><span class="ca-5"><span style="font-size:12px"><span style="font-family:宋体">希尔排序的示例：</span></span></span></p>
<p><span class="ca-5"><span style="font-size:12px"><span style="font-family:宋体"><img alt="" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/1342577299_5077.jpg"></span></span></span></p>
<p><span class="ca-5"><span style="font-size:12px"><span style="font-family:宋体"><br>
</span></span></span></p>
<p><strong><span style="color:#3333ff; font-size:16px">算法实现：</span></strong></p>
<p>&nbsp;</p>
<p>我们简单处理增量序列：增量<span class="ca-7"></span>序列d = {n/2 ,n/4, n/8 .....1} <span class="ca-7">
<span style="font-family:Times New Roman">n</span></span><span class="ca-5">为要排序数的个数</span><br>
</p>
<p>即：先将要排序的一组记录按某个增量<span class="ca-7"><span style="font-family:Times New Roman">d</span></span><span class="ca-5">（</span><span class="ca-7"><span style="font-family:Times New Roman">n/2,n</span></span><span class="ca-5">为要排序数的个数）分成若干组子序列，每组中记录的下标相差</span><span class="ca-7"><span style="font-family:Times New Roman">d.</span></span><span class="ca-5">对每组中全部元素进行直接插入排序，然后再用一个较小的增量（</span><span class="ca-7"><span style="font-family:Times New Roman">d/2</span></span><span class="ca-5">）对它进行分组，在每组中再进行直接插入排序。继续<span style="font-size:12px">不断缩小增量直至为<span style="font-family:Times New Roman">1</span><span style="font-family:宋体">，最后使用直接插入排序完成排序。</span></span></span></p>
<div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><div style="position: absolute; left: 0px; top: 0px; width: 0px; height: 0px; z-index: 99;"><embed id="ZeroClipboardMovie_2" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="0" height="0" name="ZeroClipboardMovie_2" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=2&amp;width=0&amp;height=0" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">void</span><span>&nbsp;print(</span><span class="datatypes">int</span><span>&nbsp;a[],&nbsp;</span><span class="datatypes">int</span><span>&nbsp;n&nbsp;,</span><span class="datatypes">int</span><span>&nbsp;i){&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;i&nbsp;&lt;&lt;<span class="string">":"</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>(</span><span class="datatypes">int</span><span>&nbsp;j=&nbsp;0;&nbsp;j&lt;8;&nbsp;j++){&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;a[j]&nbsp;&lt;&lt;<span class="string">"&nbsp;"</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;endl;&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li><li class=""><span><span class="comment">/**</span>&nbsp;</span></li><li class="alt"><span><span class="comment">&nbsp;*&nbsp;直接插入排序的一般形式</span>&nbsp;</span></li><li class=""><span><span class="comment">&nbsp;*</span>&nbsp;</span></li><li class="alt"><span><span class="comment">&nbsp;*&nbsp;@param&nbsp;int&nbsp;dk&nbsp;缩小增量，如果是直接插入排序，dk=1</span>&nbsp;</span></li><li class=""><span><span class="comment">&nbsp;*</span>&nbsp;</span></li><li class="alt"><span><span class="comment">&nbsp;*/</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span><span class="keyword">void</span><span>&nbsp;ShellInsertSort(</span><span class="datatypes">int</span><span>&nbsp;a[],&nbsp;</span><span class="datatypes">int</span><span>&nbsp;n,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;dk)&nbsp;&nbsp;</span></span></li><li class=""><span>{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>(</span><span class="datatypes">int</span><span>&nbsp;i=&nbsp;dk;&nbsp;i&lt;n;&nbsp;++i){&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>(a[i]&nbsp;&lt;&nbsp;a[i-dk]){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//若第i个元素大于i-1元素，直接插入。小于的话，移动有序表后插入</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;j&nbsp;=&nbsp;i-dk;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;x&nbsp;=&nbsp;a[i];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//复制为哨兵，即存储待排序元素</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a[i]&nbsp;=&nbsp;a[i-dk];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//首先后移一个元素</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span><span>(x&nbsp;&lt;&nbsp;a[j]){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//查找在有序表的插入位置</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a[j+dk]&nbsp;=&nbsp;a[j];&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;-=&nbsp;dk;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//元素后移</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a[j+dk]&nbsp;=&nbsp;x;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//插入到正确位置</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(a,&nbsp;n,i&nbsp;);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span><span class="comment">/**</span>&nbsp;</span></li><li class=""><span><span class="comment">&nbsp;*&nbsp;先按增量d（n/2,n为要排序数的个数进行希尔排序</span>&nbsp;</span></li><li class="alt"><span><span class="comment">&nbsp;*</span>&nbsp;</span></li><li class=""><span><span class="comment">&nbsp;*/</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="keyword">void</span><span>&nbsp;shellSort(</span><span class="datatypes">int</span><span>&nbsp;a[],&nbsp;</span><span class="datatypes">int</span><span>&nbsp;n){&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;dk&nbsp;=&nbsp;n/2;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span><span>(&nbsp;dk&nbsp;&gt;=&nbsp;1&nbsp;&nbsp;){&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ShellInsertSort(a,&nbsp;n,&nbsp;dk);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dk&nbsp;=&nbsp;dk/2;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li><li class="alt"><span><span class="datatypes">int</span><span>&nbsp;main(){&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;a[8]&nbsp;=&nbsp;{3,1,5,7,2,4,9,6};&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//ShellInsertSort(a,8,1);&nbsp;//直接插入排序</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;shellSort(a,8);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//希尔插入排序</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;print(a,8,8);&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre class="cpp" name="code" style="display: none;">void print(int a[], int n ,int i){
	cout&lt;&lt;i &lt;&lt;":";
	for(int j= 0; j&lt;8; j++){
		cout&lt;&lt;a[j] &lt;&lt;" ";
	}
	cout&lt;&lt;endl;
}
/**
 * 直接插入排序的一般形式
 *
 * @param int dk 缩小增量，如果是直接插入排序，dk=1
 *
 */

void ShellInsertSort(int a[], int n, int dk)
{
	for(int i= dk; i&lt;n; ++i){
		if(a[i] &lt; a[i-dk]){			//若第i个元素大于i-1元素，直接插入。小于的话，移动有序表后插入
			int j = i-dk;	
			int x = a[i];			//复制为哨兵，即存储待排序元素
			a[i] = a[i-dk];			//首先后移一个元素
			while(x &lt; a[j]){		//查找在有序表的插入位置
				a[j+dk] = a[j];
				j -= dk;			 //元素后移
			}
			a[j+dk] = x;			//插入到正确位置
		}
		print(a, n,i );
	}
	
}

/**
 * 先按增量d（n/2,n为要排序数的个数进行希尔排序
 *
 */
void shellSort(int a[], int n){

	int dk = n/2;
	while( dk &gt;= 1  ){
		ShellInsertSort(a, n, dk);
		dk = dk/2;
	}
}
int main(){
	int a[8] = {3,1,5,7,2,4,9,6};
	//ShellInsertSort(a,8,1); //直接插入排序
	shellSort(a,8);			  //希尔插入排序
	print(a,8,8);
}
</pre>
<br>
<p><span class="ca-5"></span></p>
<div id="comment">希尔排序时效分析很难，关键码的比较次数与记录移动次数依赖于增量因子序列d的选取，特定情况下可以准确估算出关键码的比较次数和记录的移动次数。目前还没有人给出选取最好的<span class="ca-5">增量因子序列</span>的方法。<span class="ca-5">增量因子序列</span>可以有各种取法，有取奇数的，也有取质数的，但需要注意：<span class="ca-5"><span class="ca-5">增量因子</span></span>中除1 外没有公因子，且最后一个<span class="ca-5"><span class="ca-5">增量因子</span></span>必须为1。希尔排序方法是一个不稳定的排序方法。</div>
<p><br>
</p>
<h2 class="headline-1 bk-sidecatalog-title" style="border-bottom:rgb(222,223,225) 1px solid; text-align:left; padding-bottom:6px; line-height:26px; margin:0px 0px 10px; padding-left:0px; padding-right:0px; font-family:Arial; color:rgb(51,51,51); clear:both; padding-top:0px"><a name="t3"></a>
<span style="color:#336699"><span style="line-height:36px; font-size:21px">3. 选择排序—简单选择排序（Simple Selection Sort）</span></span></h2>
<p><strong><span style="color:#3333ff; font-size:16px">基本思想：</span></strong></p>
<p>在要排序的一组数中，选出最小（或者最大）的<span class="ca-5">一</span><span class="ca-5">个数与<span style="color:#009900">第1个位置</span>的数交换；</span><span class="ca-5">然后在剩下的数当中再找最小（或者最大）的与<span style="color:#009900">第2个位置</span>的数交换，依次类推，直到第n-1个元素（倒数第二个数）和第n个元素（最后</span><span class="ca-5">一</span><span class="ca-5">个数）比较为止。</span></p>
<p><span class="ca-5"><span class="ca-5"><span style="font-size:12px"><span style="font-family:宋体">简单选择排序的示例：</span></span></span><br>
</span></p>
<p><span class="ca-5"></span>&nbsp;<img alt="" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/1342586432_7130.jpg"></p>
<p><span style="color:#3333ff"><strong><span style="font-size:16px">操作方法：</span></strong></span></p>
<p><span style="color:#000000">第一趟，从n 个记录中找出关键码最小的记录与第一个记录交换；</span></p>
<p><span style="color:#000000">第二趟，从第二个记录开始的n-1 个记录中再选出关键码最小的记录与第二个记录交换；</span></p>
<p><span style="color:#000000">以此类推.....<br>
</span></p>
<p><span style="color:#000000">第i 趟，则从第i 个记录开始的n-i+1 个记录中选出关键码最小的记录与第i 个记录交换，</span></p>
<p><span style="color:#000000">直到整个序列按关键码有序。</span><br>
<br>
<br>
</p>
<p><span class="ca-5"><strong><span style="color:#3333ff; font-size:16px">算法实现：</span></strong></span></p>
<div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><div style="position: absolute; left: 0px; top: 0px; width: 0px; height: 0px; z-index: 99;"><embed id="ZeroClipboardMovie_3" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="0" height="0" name="ZeroClipboardMovie_3" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=3&amp;width=0&amp;height=0" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">void</span><span>&nbsp;print(</span><span class="datatypes">int</span><span>&nbsp;a[],&nbsp;</span><span class="datatypes">int</span><span>&nbsp;n&nbsp;,</span><span class="datatypes">int</span><span>&nbsp;i){&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;<span class="string">"第"</span><span>&lt;&lt;i+1&nbsp;&lt;&lt;</span><span class="string">"趟&nbsp;:&nbsp;"</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>(</span><span class="datatypes">int</span><span>&nbsp;j=&nbsp;0;&nbsp;j&lt;8;&nbsp;j++){&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;a[j]&nbsp;&lt;&lt;<span class="string">"&nbsp;&nbsp;"</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;endl;&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li><li class=""><span><span class="comment">/**</span>&nbsp;</span></li><li class="alt"><span><span class="comment">&nbsp;*&nbsp;数组的最小值</span>&nbsp;</span></li><li class=""><span><span class="comment">&nbsp;*</span>&nbsp;</span></li><li class="alt"><span><span class="comment">&nbsp;*&nbsp;@return&nbsp;int&nbsp;数组的键值</span>&nbsp;</span></li><li class=""><span><span class="comment">&nbsp;*/</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="datatypes">int</span><span>&nbsp;SelectMinKey(</span><span class="datatypes">int</span><span>&nbsp;a[],&nbsp;</span><span class="datatypes">int</span><span>&nbsp;n,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;i)&nbsp;&nbsp;</span></span></li><li class=""><span>{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;k&nbsp;=&nbsp;i;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>(</span><span class="datatypes">int</span><span>&nbsp;j=i+1&nbsp;;j&lt;&nbsp;n;&nbsp;++j)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>(a[k]&nbsp;&gt;&nbsp;a[j])&nbsp;k&nbsp;=&nbsp;j;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;k;&nbsp;&nbsp;</span></span></li><li class=""><span>}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span><span class="comment">/**</span>&nbsp;</span></li><li class="alt"><span><span class="comment">&nbsp;*&nbsp;选择排序</span>&nbsp;</span></li><li class=""><span><span class="comment">&nbsp;*</span>&nbsp;</span></li><li class="alt"><span><span class="comment">&nbsp;*/</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="keyword">void</span><span>&nbsp;selectSort(</span><span class="datatypes">int</span><span>&nbsp;a[],&nbsp;</span><span class="datatypes">int</span><span>&nbsp;n){&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;key,&nbsp;tmp;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>(</span><span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&lt;&nbsp;n;&nbsp;++i)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key&nbsp;=&nbsp;SelectMinKey(a,&nbsp;n,i);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//选择最小的元素</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>(key&nbsp;!=&nbsp;i){&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp&nbsp;=&nbsp;a[i];&nbsp;&nbsp;a[i]&nbsp;=&nbsp;a[key];&nbsp;a[key]&nbsp;=&nbsp;tmp;&nbsp;<span class="comment">//最小元素与第i位置元素互换</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(a,&nbsp;&nbsp;n&nbsp;,&nbsp;i);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li><li class=""><span><span class="datatypes">int</span><span>&nbsp;main(){&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;a[8]&nbsp;=&nbsp;{3,1,5,7,2,4,9,6};&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;<span class="string">"初始值："</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>(</span><span class="datatypes">int</span><span>&nbsp;j=&nbsp;0;&nbsp;j&lt;8;&nbsp;j++){&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;a[j]&nbsp;&lt;&lt;<span class="string">"&nbsp;&nbsp;"</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;endl&lt;&lt;endl;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;selectSort(a,&nbsp;8);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;print(a,8,8);&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre class="cpp" name="code" style="display: none;">void print(int a[], int n ,int i){
	cout&lt;&lt;"第"&lt;&lt;i+1 &lt;&lt;"趟 : ";
	for(int j= 0; j&lt;8; j++){
		cout&lt;&lt;a[j] &lt;&lt;"  ";
	}
	cout&lt;&lt;endl;
}
/**
 * 数组的最小值
 *
 * @return int 数组的键值
 */
int SelectMinKey(int a[], int n, int i)
{
	int k = i;
	for(int j=i+1 ;j&lt; n; ++j) {
		if(a[k] &gt; a[j]) k = j;
	}
	return k;
}

/**
 * 选择排序
 *
 */
void selectSort(int a[], int n){
	int key, tmp;
	for(int i = 0; i&lt; n; ++i) {
		key = SelectMinKey(a, n,i);           //选择最小的元素
		if(key != i){
			tmp = a[i];  a[i] = a[key]; a[key] = tmp; //最小元素与第i位置元素互换
		}
		print(a,  n , i);
	}
}
int main(){
	int a[8] = {3,1,5,7,2,4,9,6};
	cout&lt;&lt;"初始值：";
	for(int j= 0; j&lt;8; j++){
		cout&lt;&lt;a[j] &lt;&lt;"  ";
	}
	cout&lt;&lt;endl&lt;&lt;endl;
	selectSort(a, 8);
	print(a,8,8);
}
</pre>
<br>
<p><span style="font-weight:bold"><span style="font-size:16px"><span style="color:#3333ff">&nbsp;简单选择排序的改进——二元选择排序<span lang="EN-US" style="font-size:12pt"></span></span></span></span></p>
<p>简单选择排序，每趟循环只能确定一个元素排序后的定位。我们可以考虑改进为每趟循环确定两个元素（当前趟最大和最小记录）的位置<span style="font-family:Times New Roman">,</span>从而减少排序所需的循环次数。改进后对<span style="font-family:Times New Roman">n</span>个数据进行排序，最多只需进行<span style="font-family:Times New Roman">[n/2]</span>趟循环即可。具体实现如下：</p>
<div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><div style="position: absolute; left: 0px; top: 0px; width: 0px; height: 0px; z-index: 99;"><embed id="ZeroClipboardMovie_4" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="0" height="0" name="ZeroClipboardMovie_4" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=4&amp;width=0&amp;height=0" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">void</span><span>&nbsp;SelectSort(</span><span class="datatypes">int</span><span>&nbsp;r[],</span><span class="datatypes">int</span><span>&nbsp;n)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;i&nbsp;,j&nbsp;,&nbsp;min&nbsp;,max,&nbsp;tmp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>&nbsp;(i=1&nbsp;;i&nbsp;&lt;=&nbsp;n/2;i++)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;做不超过n/2趟选择排序&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min&nbsp;=&nbsp;i;&nbsp;max&nbsp;=&nbsp;i&nbsp;;&nbsp;<span class="comment">//分别记录最大和最小关键字记录位置</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>&nbsp;(j=&nbsp;i+1;&nbsp;j&lt;=&nbsp;n-i;&nbsp;j++)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(r[j]&nbsp;&gt;&nbsp;r[max])&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max&nbsp;=&nbsp;j&nbsp;;&nbsp;<span class="keyword">continue</span><span>&nbsp;;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(r[j]&lt;&nbsp;r[min])&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min&nbsp;=&nbsp;j&nbsp;;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//该交换操作还可分情况讨论以提高效率</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp&nbsp;=&nbsp;r[i-1];&nbsp;r[i-1]&nbsp;=&nbsp;r[min];&nbsp;r[min]&nbsp;=&nbsp;tmp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp&nbsp;=&nbsp;r[n-i];&nbsp;r[n-i]&nbsp;=&nbsp;r[max];&nbsp;r[max]&nbsp;=&nbsp;tmp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre class="cpp" name="code" style="display: none;">void SelectSort(int r[],int n) {
	int i ,j , min ,max, tmp;
	for (i=1 ;i &lt;= n/2;i++) {  
		// 做不超过n/2趟选择排序 
		min = i; max = i ; //分别记录最大和最小关键字记录位置
		for (j= i+1; j&lt;= n-i; j++) {
			if (r[j] &gt; r[max]) { 
				max = j ; continue ; 
			}  
			if (r[j]&lt; r[min]) { 
				min = j ; 
			}   
	  }  
	  //该交换操作还可分情况讨论以提高效率
	  tmp = r[i-1]; r[i-1] = r[min]; r[min] = tmp;
	  tmp = r[n-i]; r[n-i] = r[max]; r[max] = tmp; 

	} 
}</pre>
<br>
<h2 class="headline-1 bk-sidecatalog-title" style="border-bottom:rgb(222,223,225) 1px solid; text-align:left; padding-bottom:6px; line-height:26px; margin:0px 0px 10px; padding-left:0px; padding-right:0px; font-family:Arial; color:rgb(51,51,51); clear:both; padding-top:0px"><a name="t4"></a>
<span style="color:#336699"><span style="line-height:36px; font-size:21px">4. 选择排序—堆排序（Heap Sort）<br>
</span></span></h2>
<span style="color:black">堆排序是一种<span style="color:#3333ff">树形选择排序</span>，是对直接选择排序的有效改进。</span><br>
<p align="left"><span style="color:#3333ff; font-size:16px"><strong>基本思想：</strong></span></p>
<p align="left"><span style="color:black">堆的定义如下：具有n</span>个元素的序列（k1,k2,...,kn),当且仅当满足</p>
<img alt="" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/1342589718_3742.jpg"><br>
<p align="left">时称之为堆。由堆的定义可以看出，<span style="color:#33cc00"><strong>堆顶元素</strong></span>（即第一个元素）必为最小项（小顶堆）。<br>
若以一维数组存储一个堆，则堆对应一棵<a target="_blank" style="color: #0000F0; display:inline; position:static; background:none;" href="http://www.so.com/s?q=%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91&ie=utf-8&src=se_lighten_f">完全二叉树</a>，且所有非叶结点的值均不大于(或不小于)其子女的值，根结点（堆顶元素）的值是最小(或最大)的。如：</p>
<p align="left">（a）大顶堆序列：（96, 83,27,38,11,09)</p>
<p align="left">&nbsp; (b)&nbsp; 小顶堆序列：（12，36，24，85，47，30，53，91）<br>
</p>
<p align="left"><img alt="" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/1342592355_2560.jpg"><br>
</p>
<p align="left"><br>
</p>
<p align="left">初始时把要排序的n个数的序列看作是一棵<span style="color:#ff6600"><strong>顺序存储的二叉树（一维数组存储二叉树）</strong></span>，调整它们的存储序，使之成为一个堆，将堆顶元素输出，得到n 个元素中最小(或最大)的元素，这时堆的根节点的数最小（或者最大）。然后对前面(n-1)个元素重新调整使之成为堆，输出堆顶元素，得到n 个元素中次小(或次大)的元素。依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。称这个过程为<span style="color:#3333ff"><strong>堆排序</strong></span>。</p>
<p align="left">因此，实现堆排序需解决两个问题：<br>
1. 如何将n 个待排序的数建成堆；<br>
2. 输出堆顶元素后，怎样调整剩余n-1 个元素，使其成为一个新堆。</p>
<p align="left"><br>
<span style="color:#3333ff">首先讨论第二个问题：输出堆顶元素后，对剩余n-1元素重新建成堆的调整过程。</span><br>
调整小顶堆的方法：</p>
<p align="left">1）设有m 个元素的堆，输出堆顶元素后，剩下m-1 个元素。将堆底元素送入堆顶（（最后一个元素与堆顶进行交换），堆被破坏，其原因仅是根结点不满足堆的性质。</p>
<p align="left">2）将根结点与左、右子树中较小元素的进行交换。</p>
<p align="left">3）若与左子树交换：如果左子树堆被破坏，即左子树的根结点不满足堆的性质，则重复方法 （2）.</p>
<p align="left">4）若与右子树交换，如果右子树堆被破坏，即右子树的根结点不满足堆的性质。则重复方法 （2）.</p>
<p align="left">5）继续对不满足堆性质的子树进行上述交换操作，直到叶子结点，堆被建成。</p>
<p align="left"><span style="color:#009900">称这个自根结点到叶子结点的调整过程为筛选。如图：</span></p>
<p align="left"><span style="color:#009900"><img alt="" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/1342595226_8095.jpg"><br>
</span></p>
<p align="left"><br>
<span style="color:#3333ff">再讨论对n 个元素初始建堆的过程。</span><br>
建堆方法：对初始序列建堆的过程，就是一个反复进行筛选的过程。</p>
<p align="left">1）n 个结点的完全二叉树，则最后一个结点是第<img alt="" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/1342595562_4106.jpg">个结点的子树。</p>
<p align="left">2）筛选从第<img alt="" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/1342595562_4106.jpg">个结点为根的子树开始，该子树成为堆。</p>
<p align="left">3）之后向前依次对各结点为根的子树进行筛选，使之成为堆，直到根结点。</p>
<p align="left">如图建堆初始过程：无序序列：（49，38，65，97，76，13，27，49）<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <img alt="" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/1342596333_5296.jpg"></p>
<p align="left"><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <img alt="" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/1342596352_2401.jpg"><br>
</p>
<p>&nbsp;</p>
<p><span style="color:#3333ff; font-size:16px"><strong>&nbsp;算法的实现：</strong></span></p>
<p>从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆的渗透函数，二是反复调用渗透函数实现排序的函数。</p>
<div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><div style="position: absolute; left: 0px; top: 0px; width: 0px; height: 0px; z-index: 99;"><embed id="ZeroClipboardMovie_5" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="0" height="0" name="ZeroClipboardMovie_5" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=5&amp;width=0&amp;height=0" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">void</span><span>&nbsp;print(</span><span class="datatypes">int</span><span>&nbsp;a[],&nbsp;</span><span class="datatypes">int</span><span>&nbsp;n){&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>(</span><span class="datatypes">int</span><span>&nbsp;j=&nbsp;0;&nbsp;j&lt;n;&nbsp;j++){&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;a[j]&nbsp;&lt;&lt;<span class="string">"&nbsp;&nbsp;"</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;endl;&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span><span class="comment">/**</span>&nbsp;</span></li><li class="alt"><span><span class="comment">&nbsp;*&nbsp;已知H[s…m]除了H[s]&nbsp;外均满足堆的定义</span>&nbsp;</span></li><li class=""><span><span class="comment">&nbsp;*&nbsp;调整H[s],使其成为大顶堆.即将对第s个结点为根的子树筛选,&nbsp;</span>&nbsp;</span></li><li class="alt"><span><span class="comment">&nbsp;*</span>&nbsp;</span></li><li class=""><span><span class="comment">&nbsp;*&nbsp;@param&nbsp;H是待调整的堆数组</span>&nbsp;</span></li><li class="alt"><span><span class="comment">&nbsp;*&nbsp;@param&nbsp;s是待调整的数组元素的位置</span>&nbsp;</span></li><li class=""><span><span class="comment">&nbsp;*&nbsp;@param&nbsp;length是数组的长度</span>&nbsp;</span></li><li class="alt"><span><span class="comment">&nbsp;*</span>&nbsp;</span></li><li class=""><span><span class="comment">&nbsp;*/</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="keyword">void</span><span>&nbsp;HeapAdjust(</span><span class="datatypes">int</span><span>&nbsp;H[],</span><span class="datatypes">int</span><span>&nbsp;s,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;length)&nbsp;&nbsp;</span></span></li><li class=""><span>{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;tmp&nbsp;&nbsp;=&nbsp;H[s];&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;child&nbsp;=&nbsp;2*s+1;&nbsp;</span><span class="comment">//左孩子结点的位置。(i+1&nbsp;为当前调整结点的右孩子结点的位置)</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span><span>&nbsp;(child&nbsp;&lt;&nbsp;length)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>(child+1&nbsp;&lt;length&nbsp;&amp;&amp;&nbsp;H[child]&lt;H[child+1])&nbsp;{&nbsp;</span><span class="comment">//&nbsp;如果右孩子大于左孩子(找到比当前待调整结点大的孩子结点)</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++child&nbsp;;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>(H[s]&lt;H[child])&nbsp;{&nbsp;&nbsp;</span><span class="comment">//&nbsp;如果较大的子结点大于父结点</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;H[s]&nbsp;=&nbsp;H[child];&nbsp;<span class="comment">//&nbsp;那么把较大的子结点往上移动，替换它的父结点</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;=&nbsp;child;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;重新设置s&nbsp;,即待调整的下一个结点的位置</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;child&nbsp;=&nbsp;2*s+1;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;<span class="keyword">else</span><span>&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;如果当前待调整结点大于它的左右孩子，则不需要调整，直接退出</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">break</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;H[s]&nbsp;=&nbsp;tmp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;当前待调整的结点放到比其大的孩子结点位置上</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;print(H,length);&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span><span class="comment">/**</span>&nbsp;</span></li><li class="alt"><span><span class="comment">&nbsp;*&nbsp;初始堆进行调整</span>&nbsp;</span></li><li class=""><span><span class="comment">&nbsp;*&nbsp;将H[0..length-1]建成堆</span>&nbsp;</span></li><li class="alt"><span><span class="comment">&nbsp;*&nbsp;调整完之后第一个元素是序列的最小的元素</span>&nbsp;</span></li><li class=""><span><span class="comment">&nbsp;*/</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="keyword">void</span><span>&nbsp;BuildingHeap(</span><span class="datatypes">int</span><span>&nbsp;H[],&nbsp;</span><span class="datatypes">int</span><span>&nbsp;length)&nbsp;&nbsp;</span></span></li><li class=""><span>{&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//最后一个有孩子的节点的位置&nbsp;i=&nbsp;&nbsp;(length&nbsp;-1)&nbsp;/&nbsp;2</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>&nbsp;(</span><span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;(length&nbsp;-1)&nbsp;/&nbsp;2&nbsp;;&nbsp;i&nbsp;&gt;=&nbsp;0;&nbsp;--i)&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HeapAdjust(H,i,length);&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li><li class="alt"><span><span class="comment">/**</span>&nbsp;</span></li><li class=""><span><span class="comment">&nbsp;*&nbsp;堆排序算法</span>&nbsp;</span></li><li class="alt"><span><span class="comment">&nbsp;*/</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="keyword">void</span><span>&nbsp;HeapSort(</span><span class="datatypes">int</span><span>&nbsp;H[],</span><span class="datatypes">int</span><span>&nbsp;length)&nbsp;&nbsp;</span></span></li><li class="alt"><span>{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//初始堆</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;BuildingHeap(H,&nbsp;length);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//从最后一个元素开始对序列进行调整</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>&nbsp;(</span><span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;length&nbsp;-&nbsp;1;&nbsp;i&nbsp;&gt;&nbsp;0;&nbsp;--i)&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//交换堆顶元素H[0]和堆中最后一个元素</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;temp&nbsp;=&nbsp;H[i];&nbsp;H[i]&nbsp;=&nbsp;H[0];&nbsp;H[0]&nbsp;=&nbsp;temp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//每次交换堆顶元素和堆中最后一个元素之后，都要对堆进行调整</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HeapAdjust(H,0,i);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span><span class="datatypes">int</span><span>&nbsp;main(){&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;H[10]&nbsp;=&nbsp;{3,1,5,7,2,4,9,6,10,8};&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;<span class="string">"初始值："</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;print(H,10);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;HeapSort(H,10);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//selectSort(a,&nbsp;8);</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;<span class="string">"结果："</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;print(H,10);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre class="cpp" name="code" style="display: none;">void print(int a[], int n){
	for(int j= 0; j&lt;n; j++){
		cout&lt;&lt;a[j] &lt;&lt;"  ";
	}
	cout&lt;&lt;endl;
}



/**
 * 已知H[s…m]除了H[s] 外均满足堆的定义
 * 调整H[s],使其成为大顶堆.即将对第s个结点为根的子树筛选, 
 *
 * @param H是待调整的堆数组
 * @param s是待调整的数组元素的位置
 * @param length是数组的长度
 *
 */
void HeapAdjust(int H[],int s, int length)
{
	int tmp  = H[s];
	int child = 2*s+1; //左孩子结点的位置。(i+1 为当前调整结点的右孩子结点的位置)
    while (child &lt; length) {
		if(child+1 &lt;length &amp;&amp; H[child]&lt;H[child+1]) { // 如果右孩子大于左孩子(找到比当前待调整结点大的孩子结点)
			++child ;
		}
		if(H[s]&lt;H[child]) {  // 如果较大的子结点大于父结点
			H[s] = H[child]; // 那么把较大的子结点往上移动，替换它的父结点
			s = child;		 // 重新设置s ,即待调整的下一个结点的位置
			child = 2*s+1;
		}  else {			 // 如果当前待调整结点大于它的左右孩子，则不需要调整，直接退出
			 break;
		}
		H[s] = tmp;			// 当前待调整的结点放到比其大的孩子结点位置上
	}
	print(H,length);
}


/**
 * 初始堆进行调整
 * 将H[0..length-1]建成堆
 * 调整完之后第一个元素是序列的最小的元素
 */
void BuildingHeap(int H[], int length)
{ 
	//最后一个有孩子的节点的位置 i=  (length -1) / 2
	for (int i = (length -1) / 2 ; i &gt;= 0; --i)
		HeapAdjust(H,i,length);
}
/**
 * 堆排序算法
 */
void HeapSort(int H[],int length)
{
    //初始堆
	BuildingHeap(H, length);
	//从最后一个元素开始对序列进行调整
	for (int i = length - 1; i &gt; 0; --i)
	{
		//交换堆顶元素H[0]和堆中最后一个元素
		int temp = H[i]; H[i] = H[0]; H[0] = temp;
		//每次交换堆顶元素和堆中最后一个元素之后，都要对堆进行调整
		HeapAdjust(H,0,i);
  }
} 

int main(){
	int H[10] = {3,1,5,7,2,4,9,6,10,8};
	cout&lt;&lt;"初始值：";
	print(H,10);
	HeapSort(H,10);
	//selectSort(a, 8);
	cout&lt;&lt;"结果：";
	print(H,10);

}

</pre>
<br>
<br>
<p><span style="color:#3333ff"><strong><span style="font-size:16px">分析:</span></strong></span><strong><br>
</strong></p>
<p>设树深度为k，<img alt="" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/1342597015_2320.jpg" height="20" width="95">。从根到叶的筛选，元素比较次数至多2(k-1)次，交换记录至多k 次。所以，在建好堆后，排序过程中的筛选次数不超过下式：&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <img alt="" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/1342597082_9043.jpg"><br>
</p>
<p>而建堆时的比较次数不超过4n 次，因此堆排序最坏情况下，时间复杂度也为：O(nlogn )。</p>
<p>&nbsp;</p>
<h2 class="headline-1 bk-sidecatalog-title" style="border-bottom:rgb(222,223,225) 1px solid; text-align:left; padding-bottom:6px; line-height:26px; margin:0px 0px 10px; padding-left:0px; padding-right:0px; font-family:Arial; color:rgb(51,51,51); clear:both; padding-top:0px"><a name="t5"></a>
<span style="color:#336699"><span style="line-height:36px; font-size:21px">5. 交换排序—冒泡排序（Bubble Sort）</span></span></h2>
<p><strong><span style="color:#3333ff; font-size:16px">基本思想：</span></strong></p>
<p>在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大<span class="ca-5">的数往下沉</span><span class="ca-5">，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。</span></p>
<p>冒泡排序的示例：</p>
<p>&nbsp;<img alt="" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/1342782078_9990.jpg"></p>
<p><span style="font-weight:bold"><span style="font-size:16px"><span style="color:#3333ff">算法的实现：<span class="ca-5"></span></span></span></span></p>
<p><span class="ca-5"></span></p>
<div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><div style="position: absolute; left: 0px; top: 0px; width: 0px; height: 0px; z-index: 99;"><embed id="ZeroClipboardMovie_6" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="0" height="0" name="ZeroClipboardMovie_6" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=6&amp;width=0&amp;height=0" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">void</span><span>&nbsp;bubbleSort(</span><span class="datatypes">int</span><span>&nbsp;a[],&nbsp;</span><span class="datatypes">int</span><span>&nbsp;n){&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>(</span><span class="datatypes">int</span><span>&nbsp;i&nbsp;=0&nbsp;;&nbsp;i&lt;&nbsp;n-1;&nbsp;++i)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>(</span><span class="datatypes">int</span><span>&nbsp;j&nbsp;=&nbsp;0;&nbsp;j&nbsp;&lt;&nbsp;n-i-1;&nbsp;++j)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>(a[j]&nbsp;&gt;&nbsp;a[j+1])&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;tmp&nbsp;=&nbsp;a[j]&nbsp;;&nbsp;a[j]&nbsp;=&nbsp;a[j+1]&nbsp;;&nbsp;&nbsp;a[j+1]&nbsp;=&nbsp;tmp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre class="cpp" name="code" style="display: none;">void bubbleSort(int a[], int n){
	for(int i =0 ; i&lt; n-1; ++i) {
		for(int j = 0; j &lt; n-i-1; ++j) {
			if(a[j] &gt; a[j+1])
			{
				int tmp = a[j] ; a[j] = a[j+1] ;  a[j+1] = tmp;
			}
		}
	}
}</pre>
<br>
<br>
<p><strong><span style="color:#3333ff; font-size:16px">冒泡排序算法的改进</span></strong></p>
<p>对冒泡排序常见的改进方法是加入一标志性变量<span style="font-family:Times New Roman">exchange</span>，用于标志某一趟排序过程中是否有数据交换，如果进行某一趟排序时并没有进行数据交换，则说明数据已经按要求排列好，可立即结束排序，避免不必要的比较过程。本文再提供以下两种改进算法：</p>
<p><span style="font-family:Times New Roman">1</span>．设置一标志性变量<span style="font-family:Times New Roman">pos,</span>用于记录每趟排序中最后一次进行交换的位置。由于<span style="font-family:Times New Roman">pos</span>位置之后的记录均已交换到位<span style="font-family:Times New Roman">,</span>故在进行下一趟排序时只要扫描到<span style="font-family:Times New Roman">pos</span>位置即可。</p>
<p>改进后算法如下<span style="font-family:Times New Roman">:</span></p>
<div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><div style="position: absolute; left: 0px; top: 0px; width: 0px; height: 0px; z-index: 99;"><embed id="ZeroClipboardMovie_7" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="0" height="0" name="ZeroClipboardMovie_7" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=7&amp;width=0&amp;height=0" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">void</span><span>&nbsp;Bubble_1&nbsp;(&nbsp;</span><span class="datatypes">int</span><span>&nbsp;r[],&nbsp;</span><span class="datatypes">int</span><span>&nbsp;n)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;i=&nbsp;n&nbsp;-1;&nbsp;&nbsp;</span><span class="comment">//初始时,最后位置保持不变</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span><span>&nbsp;(&nbsp;i&gt;&nbsp;0)&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;pos=&nbsp;0;&nbsp;</span><span class="comment">//每趟开始时,无记录交换</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>&nbsp;(</span><span class="datatypes">int</span><span>&nbsp;j=&nbsp;0;&nbsp;j&lt;&nbsp;i;&nbsp;j++)&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(r[j]&gt;&nbsp;r[j+1])&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pos=&nbsp;j;&nbsp;<span class="comment">//记录交换的位置&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;tmp&nbsp;=&nbsp;r[j];&nbsp;r[j]=r[j+1];r[j+1]=tmp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i=&nbsp;pos;&nbsp;<span class="comment">//为下一趟排序作准备</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;&nbsp;&nbsp;</span></li></ol></div><pre class="cpp" name="code" style="display: none;">void Bubble_1 ( int r[], int n) {
	int i= n -1;  //初始时,最后位置保持不变
	while ( i&gt; 0) { 
		int pos= 0; //每趟开始时,无记录交换
		for (int j= 0; j&lt; i; j++)
			if (r[j]&gt; r[j+1]) {
				pos= j; //记录交换的位置 
				int tmp = r[j]; r[j]=r[j+1];r[j+1]=tmp;
			} 
		i= pos; //为下一趟排序作准备
	 } 
}  
</pre>
<br>
<p><span style="font-family:Times New Roman">2</span>．传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值<span style="font-family:Times New Roman">,</span>我们考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值<span style="font-family:Times New Roman">(</span>最大者和最小者<span style="font-family:Times New Roman">)
 , </span>从而使排序趟数几乎减少了一半。</p>
<p>改进后的算法实现为<span style="font-family:Times New Roman">:</span></p>
<div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><div style="position: absolute; left: 0px; top: 0px; width: 0px; height: 0px; z-index: 99;"><embed id="ZeroClipboardMovie_8" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="0" height="0" name="ZeroClipboardMovie_8" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=8&amp;width=0&amp;height=0" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">void</span><span>&nbsp;Bubble_2&nbsp;(&nbsp;</span><span class="datatypes">int</span><span>&nbsp;r[],&nbsp;</span><span class="datatypes">int</span><span>&nbsp;n){&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;low&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;high=&nbsp;n&nbsp;-1;&nbsp;</span><span class="comment">//设置变量的初始值</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;tmp,j;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span><span>&nbsp;(low&nbsp;&lt;&nbsp;high)&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>&nbsp;(j=&nbsp;low;&nbsp;j&lt;&nbsp;high;&nbsp;++j)&nbsp;</span><span class="comment">//正向冒泡,找到最大者</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(r[j]&gt;&nbsp;r[j+1])&nbsp;{&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp&nbsp;=&nbsp;r[j];&nbsp;r[j]=r[j+1];r[j+1]=tmp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--high;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//修改high值,&nbsp;前移一位</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>&nbsp;(&nbsp;j=high;&nbsp;j&gt;low;&nbsp;--j)&nbsp;</span><span class="comment">//反向冒泡,找到最小者</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(r[j]&lt;r[j-1])&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp&nbsp;=&nbsp;r[j];&nbsp;r[j]=r[j-1];r[j-1]=tmp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++low;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//修改low值,后移一位</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;&nbsp;</span></li></ol></div><pre class="cpp" name="code" style="display: none;">void Bubble_2 ( int r[], int n){
	int low = 0; 
	int high= n -1; //设置变量的初始值
	int tmp,j;
	while (low &lt; high) {
		for (j= low; j&lt; high; ++j) //正向冒泡,找到最大者
			if (r[j]&gt; r[j+1]) {
				tmp = r[j]; r[j]=r[j+1];r[j+1]=tmp;
			} 
		--high;					//修改high值, 前移一位
		for ( j=high; j&gt;low; --j) //反向冒泡,找到最小者
			if (r[j]&lt;r[j-1]) {
				tmp = r[j]; r[j]=r[j-1];r[j-1]=tmp;
			}
		++low;					//修改low值,后移一位
	} 
} </pre>
<br>
<h2 class="headline-1 bk-sidecatalog-title" style="border-bottom:rgb(222,223,225) 1px solid; text-align:left; padding-bottom:6px; line-height:26px; margin:0px 0px 10px; padding-left:0px; padding-right:0px; font-family:Arial; color:rgb(51,51,51); clear:both; padding-top:0px"><a name="t6"></a>
<span style="color:#336699"><span style="line-height:36px; font-size:21px">6. 交换排序—快速排序（Quick Sort）</span></span></h2>
<span></span>
<p><strong><span style="color:#3333ff; font-size:16px">基本思想：</span></strong></p>
<p><span style="font-family:宋体">1）选择一个基准元素</span><span style="color:#000000">,</span><span style="color:#000000">通常选择第一个元素或者最后一个元素</span>,</p>
<p>2）通过一趟排序讲待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的&nbsp;元素值比基准值大。</p>
<p><span style="color:#000000">3）此时基准元素在其排好序后的正确位置</span></p>
<p><span style="color:#000000">4）然后</span>分别对这两部分记录<span style="font-family:宋体">用同样的方法</span>继续进行排序，直到整个序列有序。</p>
<p>快速排序的示例：</p>
<p>（a）一趟排序的过程：<br>
</p>
<p><img alt="" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/1342782317_4426.jpg"></p>
<p>（b）排序的全过程<br>
</p>
<p><img alt="" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/1342782329_8314.jpg"><br>
</p>
<p><span style="font-weight:bold"><span style="font-size:16px"><span style="color:#3333ff">算法的实现：<span class="ca-5"></span></span></span></span></p>
<p>&nbsp;递归实现：</p>
<div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><div style="position: absolute; left: 0px; top: 0px; width: 0px; height: 0px; z-index: 99;"><embed id="ZeroClipboardMovie_9" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="0" height="0" name="ZeroClipboardMovie_9" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=9&amp;width=0&amp;height=0" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">void</span><span>&nbsp;print(</span><span class="datatypes">int</span><span>&nbsp;a[],&nbsp;</span><span class="datatypes">int</span><span>&nbsp;n){&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>(</span><span class="datatypes">int</span><span>&nbsp;j=&nbsp;0;&nbsp;j&lt;n;&nbsp;j++){&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;a[j]&nbsp;&lt;&lt;<span class="string">"&nbsp;&nbsp;"</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;endl;&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span><span class="keyword">void</span><span>&nbsp;swap(</span><span class="datatypes">int</span><span>&nbsp;*a,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;*b)&nbsp;&nbsp;</span></span></li><li class="alt"><span>{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;tmp&nbsp;=&nbsp;*a;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;*a&nbsp;=&nbsp;*b;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;*b&nbsp;=&nbsp;tmp;&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span><span class="datatypes">int</span><span>&nbsp;partition(</span><span class="datatypes">int</span><span>&nbsp;a[],&nbsp;</span><span class="datatypes">int</span><span>&nbsp;low,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;high)&nbsp;&nbsp;</span></span></li><li class=""><span>{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;privotKey&nbsp;=&nbsp;a[low];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//基准元素</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span><span>(low&nbsp;&lt;&nbsp;high){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//从表的两端交替地向中间扫描</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span><span>(low&nbsp;&lt;&nbsp;high&nbsp;&nbsp;&amp;&amp;&nbsp;a[high]&nbsp;&gt;=&nbsp;privotKey)&nbsp;--high;&nbsp;&nbsp;</span><span class="comment">//从high&nbsp;所指位置向前搜索，至多到low+1&nbsp;位置。将比基准元素小的交换到低端</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap(&amp;a[low],&nbsp;&amp;a[high]);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span><span>(low&nbsp;&lt;&nbsp;high&nbsp;&nbsp;&amp;&amp;&nbsp;a[low]&nbsp;&lt;=&nbsp;privotKey&nbsp;)&nbsp;++low;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap(&amp;a[low],&nbsp;&amp;a[high]);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;print(a,10);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;low;&nbsp;&nbsp;</span></span></li><li class=""><span>}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span><span class="keyword">void</span><span>&nbsp;quickSort(</span><span class="datatypes">int</span><span>&nbsp;a[],&nbsp;</span><span class="datatypes">int</span><span>&nbsp;low,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;high){&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>(low&nbsp;&lt;&nbsp;high){&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;privotLoc&nbsp;=&nbsp;partition(a,&nbsp;&nbsp;low,&nbsp;&nbsp;high);&nbsp;&nbsp;</span><span class="comment">//将表一分为二</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quickSort(a,&nbsp;&nbsp;low,&nbsp;&nbsp;privotLoc&nbsp;-1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//递归对低子表递归排序</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quickSort(a,&nbsp;&nbsp;&nbsp;privotLoc&nbsp;+&nbsp;1,&nbsp;high);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//递归对高子表递归排序</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span><span class="datatypes">int</span><span>&nbsp;main(){&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;a[10]&nbsp;=&nbsp;{3,1,5,7,2,4,9,6,10,8};&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;<span class="string">"初始值："</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;print(a,10);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;quickSort(a,0,9);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;<span class="string">"结果："</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;print(a,10);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre class="cpp" name="code" style="display: none;">void print(int a[], int n){
	for(int j= 0; j&lt;n; j++){
		cout&lt;&lt;a[j] &lt;&lt;"  ";
	}
	cout&lt;&lt;endl;
}

void swap(int *a, int *b)
{
	int tmp = *a;
	*a = *b;
	*b = tmp;
}

int partition(int a[], int low, int high)
{
	int privotKey = a[low];								//基准元素
	while(low &lt; high){								    //从表的两端交替地向中间扫描
		while(low &lt; high  &amp;&amp; a[high] &gt;= privotKey) --high;  //从high 所指位置向前搜索，至多到low+1 位置。将比基准元素小的交换到低端
		swap(&amp;a[low], &amp;a[high]);
		while(low &lt; high  &amp;&amp; a[low] &lt;= privotKey ) ++low;
		swap(&amp;a[low], &amp;a[high]);
	}
	print(a,10);
	return low;
}


void quickSort(int a[], int low, int high){
	if(low &lt; high){
		int privotLoc = partition(a,  low,  high);  //将表一分为二
		quickSort(a,  low,  privotLoc -1);			//递归对低子表递归排序
		quickSort(a,   privotLoc + 1, high);		//递归对高子表递归排序
	}
}

int main(){
	int a[10] = {3,1,5,7,2,4,9,6,10,8};
	cout&lt;&lt;"初始值：";
	print(a,10);
	quickSort(a,0,9);
	cout&lt;&lt;"结果：";
	print(a,10);

}</pre>
<br>
<br>
<p><strong><span style="color:#3333ff; font-size:16px">分析：</span></strong></p>
<p>快速排序是通常被认为在同数量级（O(nlog2n)）的排序方法中平均性能最好的。但若初始序列按关键码有序或基本有序时，快排序反而蜕化为冒泡排序。为改进之，通常以“三者取中法”来选取基准记录，即将排序区间的两个端点与中点三个记录关键码居中的调整为支点记录。快速排序是一个不稳定的排序方法。</p>
<p>&nbsp;<br>
<strong><span style="color:#3333ff; font-size:16px">快速排序的改进</span></strong></p>
<p>在本改进算法中<span style="font-family:Times New Roman">,</span>只对长度大于<span style="font-family:Times New Roman">k</span>的子序列递归调用快速排序<span style="font-family:Times New Roman">,</span>让原序列基本有序，然后再对整个基本有序序列用插入排序算法排序。实践证明，改进后的算法时间复杂度有所降低，且当<span style="font-family:Times New Roman">k</span>取值为<span style="font-family:Times New Roman">
 8 </span>左右时<span style="font-family:Times New Roman">,</span>改进算法的性能最佳。算法思想如下：</p>
<div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><div style="position: absolute; left: 0px; top: 0px; width: 0px; height: 0px; z-index: 99;"><embed id="ZeroClipboardMovie_10" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="0" height="0" name="ZeroClipboardMovie_10" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=10&amp;width=0&amp;height=0" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">void</span><span>&nbsp;print(</span><span class="datatypes">int</span><span>&nbsp;a[],&nbsp;</span><span class="datatypes">int</span><span>&nbsp;n){&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>(</span><span class="datatypes">int</span><span>&nbsp;j=&nbsp;0;&nbsp;j&lt;n;&nbsp;j++){&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;a[j]&nbsp;&lt;&lt;<span class="string">"&nbsp;&nbsp;"</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;endl;&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span><span class="keyword">void</span><span>&nbsp;swap(</span><span class="datatypes">int</span><span>&nbsp;*a,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;*b)&nbsp;&nbsp;</span></span></li><li class="alt"><span>{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;tmp&nbsp;=&nbsp;*a;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;*a&nbsp;=&nbsp;*b;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;*b&nbsp;=&nbsp;tmp;&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span><span class="datatypes">int</span><span>&nbsp;partition(</span><span class="datatypes">int</span><span>&nbsp;a[],&nbsp;</span><span class="datatypes">int</span><span>&nbsp;low,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;high)&nbsp;&nbsp;</span></span></li><li class=""><span>{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;privotKey&nbsp;=&nbsp;a[low];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//基准元素</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span><span>(low&nbsp;&lt;&nbsp;high){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//从表的两端交替地向中间扫描</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span><span>(low&nbsp;&lt;&nbsp;high&nbsp;&nbsp;&amp;&amp;&nbsp;a[high]&nbsp;&gt;=&nbsp;privotKey)&nbsp;--high;&nbsp;</span><span class="comment">//从high&nbsp;所指位置向前搜索，至多到low+1&nbsp;位置。将比基准元素小的交换到低端</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap(&amp;a[low],&nbsp;&amp;a[high]);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span><span>(low&nbsp;&lt;&nbsp;high&nbsp;&nbsp;&amp;&amp;&nbsp;a[low]&nbsp;&lt;=&nbsp;privotKey&nbsp;)&nbsp;++low;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap(&amp;a[low],&nbsp;&amp;a[high]);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;print(a,10);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;low;&nbsp;&nbsp;</span></span></li><li class=""><span>}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span><span class="keyword">void</span><span>&nbsp;qsort_improve(</span><span class="datatypes">int</span><span>&nbsp;r[&nbsp;],</span><span class="datatypes">int</span><span>&nbsp;low,</span><span class="datatypes">int</span><span>&nbsp;high,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;k){&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>(&nbsp;high&nbsp;-low&nbsp;&gt;&nbsp;k&nbsp;)&nbsp;{&nbsp;</span><span class="comment">//长度大于k时递归,&nbsp;k为指定的数</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;pivot&nbsp;=&nbsp;partition(r,&nbsp;low,&nbsp;high);&nbsp;</span><span class="comment">//&nbsp;调用的Partition算法保持不变</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qsort_improve(r,&nbsp;low,&nbsp;pivot&nbsp;-&nbsp;1,k);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qsort_improve(r,&nbsp;pivot&nbsp;+&nbsp;1,&nbsp;high,k);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;&nbsp;</span></li><li class=""><span><span class="keyword">void</span><span>&nbsp;quickSort(</span><span class="datatypes">int</span><span>&nbsp;r[],&nbsp;</span><span class="datatypes">int</span><span>&nbsp;n,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;k){&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;qsort_improve(r,0,n,k);<span class="comment">//先调用改进算法Qsort使之基本有序</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//再用插入排序对基本有序序列排序</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>(</span><span class="datatypes">int</span><span>&nbsp;i=1;&nbsp;i&lt;=n;i&nbsp;++){&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;tmp&nbsp;=&nbsp;r[i];&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;j=i-1;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span><span>(tmp&nbsp;&lt;&nbsp;r[j]){&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r[j+1]=r[j];&nbsp;j=j-1;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r[j+1]&nbsp;=&nbsp;tmp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span><span class="datatypes">int</span><span>&nbsp;main(){&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;a[10]&nbsp;=&nbsp;{3,1,5,7,2,4,9,6,10,8};&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;<span class="string">"初始值："</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;print(a,10);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;quickSort(a,9,4);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;<span class="string">"结果："</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;print(a,10);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre class="cpp" name="code" style="display: none;">void print(int a[], int n){
	for(int j= 0; j&lt;n; j++){
		cout&lt;&lt;a[j] &lt;&lt;"  ";
	}
	cout&lt;&lt;endl;
}

void swap(int *a, int *b)
{
	int tmp = *a;
	*a = *b;
	*b = tmp;
}

int partition(int a[], int low, int high)
{
	int privotKey = a[low];					//基准元素
	while(low &lt; high){					//从表的两端交替地向中间扫描
		while(low &lt; high  &amp;&amp; a[high] &gt;= privotKey) --high; //从high 所指位置向前搜索，至多到low+1 位置。将比基准元素小的交换到低端
		swap(&amp;a[low], &amp;a[high]);
		while(low &lt; high  &amp;&amp; a[low] &lt;= privotKey ) ++low;
		swap(&amp;a[low], &amp;a[high]);
	}
	print(a,10);
	return low;
}


void qsort_improve(int r[ ],int low,int high, int k){
	if( high -low &gt; k ) { //长度大于k时递归, k为指定的数
		int pivot = partition(r, low, high); // 调用的Partition算法保持不变
		qsort_improve(r, low, pivot - 1,k);
		qsort_improve(r, pivot + 1, high,k);
	} 
} 
void quickSort(int r[], int n, int k){
	qsort_improve(r,0,n,k);//先调用改进算法Qsort使之基本有序

	//再用插入排序对基本有序序列排序
	for(int i=1; i&lt;=n;i ++){
		int tmp = r[i]; 
		int j=i-1;
		while(tmp &lt; r[j]){
			r[j+1]=r[j]; j=j-1; 
		}
		r[j+1] = tmp;
	} 

} 



int main(){
	int a[10] = {3,1,5,7,2,4,9,6,10,8};
	cout&lt;&lt;"初始值：";
	print(a,10);
	quickSort(a,9,4);
	cout&lt;&lt;"结果：";
	print(a,10);

}</pre>
<p><span style="font-family:&#39;Times New Roman&#39;"><br>
</span></p>
<h2 class="headline-1 bk-sidecatalog-title" style="border-bottom:rgb(222,223,225) 1px solid; text-align:left; padding-bottom:6px; line-height:26px; margin:0px 0px 10px; padding-left:0px; padding-right:0px; font-family:Arial; color:rgb(51,51,51); clear:both; padding-top:0px"><a name="t7"></a>
<span style="color:#336699"><span style="line-height:36px; font-size:21px">7. 归并排序（Merge Sort）<br>
</span></span></h2>
<p><br>
</p>
<p><strong><span style="color:#3333ff; font-size:16px">基本思想：</span></strong></p>
<p><span style="font-family:宋体; font-size:12px">归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</span></p>
<p>归并排序示例：</p>
<p>&nbsp;<img alt="" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/1342842633_6751.jpg"></p>
<p><br>
</p>
<p><span style="color:#3333ff; font-size:16px"><strong>合并方法：</strong></span></p>
<p><span style="font-size:12px; background-color:rgb(255,255,255)">设r[i…n]由两个有序子表r[i…m]和r[m+1…n]组成，两个子表长度分别为n-i +1、<span style="font-size:12px">n-m</span>。</span><br>
</p>
<ol>
<li><span style="font-size:12px">j=m+1；k=i；i=i; //置两个子表的起始下标及辅助数组的起始下标</span></li><li><span style="font-size:12px">若i&gt;m 或j&gt;n，转⑷ //其中一个子表已合并完，比较选取结束</span></li><li><span style="font-size:12px">//选取r[i]和r[j]较小的存入辅助数组rf<br>
如果r[i]&lt;r[j]，rf[k]=r[i]； i++； k++； 转⑵<br>
否则，rf[k]=r[j]； j++； k++； 转⑵</span></li><li><span style="font-size:12px">//将尚未处理完的子表中元素存入rf<br>
如果i&lt;=m，将r[i…m]存入rf[k…n] //前一子表非空<br>
如果j&lt;=n , &nbsp;将r[j…n] 存入rf[k…n] //后一子表非空</span></li><li><span style="font-size:12px">合并结束。</span></li></ol>
<div>
<div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><div style="position: absolute; left: 0px; top: 0px; width: 0px; height: 0px; z-index: 99;"><embed id="ZeroClipboardMovie_11" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="0" height="0" name="ZeroClipboardMovie_11" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=11&amp;width=0&amp;height=0" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="comment">//将r[i…m]和r[m&nbsp;+1&nbsp;…n]归并到辅助数组rf[i…n]</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="keyword">void</span><span>&nbsp;Merge(ElemType&nbsp;*r,ElemType&nbsp;*rf,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;i,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;m,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;n)&nbsp;&nbsp;</span></span></li><li class="alt"><span>{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;j,k;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>(j=m+1,k=i;&nbsp;i&lt;=m&nbsp;&amp;&amp;&nbsp;j&nbsp;&lt;=n&nbsp;;&nbsp;++k){&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>(r[j]&nbsp;&lt;&nbsp;r[i])&nbsp;rf[k]&nbsp;=&nbsp;r[j++];&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><span>&nbsp;rf[k]&nbsp;=&nbsp;r[i++];&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span><span>(i&nbsp;&lt;=&nbsp;m)&nbsp;&nbsp;rf[k++]&nbsp;=&nbsp;r[i++];&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span><span>(j&nbsp;&lt;=&nbsp;n)&nbsp;&nbsp;rf[k++]&nbsp;=&nbsp;r[j++];&nbsp;&nbsp;</span></span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre class="cpp" name="code" style="display: none;">//将r[i…m]和r[m +1 …n]归并到辅助数组rf[i…n]
void Merge(ElemType *r,ElemType *rf, int i, int m, int n)
{
	int j,k;
	for(j=m+1,k=i; i&lt;=m &amp;&amp; j &lt;=n ; ++k){
		if(r[j] &lt; r[i]) rf[k] = r[j++];
		else rf[k] = r[i++];
	}
	while(i &lt;= m)  rf[k++] = r[i++];
	while(j &lt;= n)  rf[k++] = r[j++];
}</pre>
<br>
</div>
<div><span style="font-size:12px"><br>
</span></div>
<p><strong><span style="color:#3333ff; font-size:16px">归并的迭代算法</span></strong></p>
<p><strong><span style="color:#3333ff; font-size:16px"><br>
</span></strong></p>
<p>1 个元素的表总是有序的。所以对n 个元素的待排序列，每个元素可看成1 个有序子表。对子表两两合并生成n/2个子表，所得子表除最后一个子表长度可能为1 外，其余子表长度均为2。再进行两两合并，直到生成n 个元素按关键码有序的表。</p>
<div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><div style="position: absolute; left: 0px; top: 0px; width: 0px; height: 0px; z-index: 99;"><embed id="ZeroClipboardMovie_12" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="0" height="0" name="ZeroClipboardMovie_12" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=12&amp;width=0&amp;height=0" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">void</span><span>&nbsp;print(</span><span class="datatypes">int</span><span>&nbsp;a[],&nbsp;</span><span class="datatypes">int</span><span>&nbsp;n){&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>(</span><span class="datatypes">int</span><span>&nbsp;j=&nbsp;0;&nbsp;j&lt;n;&nbsp;j++){&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;a[j]&nbsp;&lt;&lt;<span class="string">"&nbsp;&nbsp;"</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;endl;&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span><span class="comment">//将r[i…m]和r[m&nbsp;+1&nbsp;…n]归并到辅助数组rf[i…n]</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="keyword">void</span><span>&nbsp;Merge(ElemType&nbsp;*r,ElemType&nbsp;*rf,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;i,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;m,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;n)&nbsp;&nbsp;</span></span></li><li class=""><span>{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;j,k;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>(j=m+1,k=i;&nbsp;i&lt;=m&nbsp;&amp;&amp;&nbsp;j&nbsp;&lt;=n&nbsp;;&nbsp;++k){&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>(r[j]&nbsp;&lt;&nbsp;r[i])&nbsp;rf[k]&nbsp;=&nbsp;r[j++];&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><span>&nbsp;rf[k]&nbsp;=&nbsp;r[i++];&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span><span>(i&nbsp;&lt;=&nbsp;m)&nbsp;&nbsp;rf[k++]&nbsp;=&nbsp;r[i++];&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span><span>(j&nbsp;&lt;=&nbsp;n)&nbsp;&nbsp;rf[k++]&nbsp;=&nbsp;r[j++];&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;print(rf,n+1);&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span><span class="keyword">void</span><span>&nbsp;MergeSort(ElemType&nbsp;*r,&nbsp;ElemType&nbsp;*rf,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;lenght)&nbsp;&nbsp;</span></span></li><li class=""><span>{&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;len&nbsp;=&nbsp;1;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;ElemType&nbsp;*q&nbsp;=&nbsp;r&nbsp;;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;ElemType&nbsp;*tmp&nbsp;;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span><span>(len&nbsp;&lt;&nbsp;lenght)&nbsp;{&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;s&nbsp;=&nbsp;len;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;len&nbsp;=&nbsp;2&nbsp;*&nbsp;s&nbsp;;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span><span>(i+&nbsp;len&nbsp;&lt;lenght){&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Merge(q,&nbsp;rf,&nbsp;&nbsp;i,&nbsp;i+&nbsp;s-1,&nbsp;i+&nbsp;len-1&nbsp;);&nbsp;<span class="comment">//对等长的两个子表合并</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;i+&nbsp;len;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>(i&nbsp;+&nbsp;s&nbsp;&lt;&nbsp;lenght){&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Merge(q,&nbsp;rf,&nbsp;&nbsp;i,&nbsp;i+&nbsp;s&nbsp;-1,&nbsp;lenght&nbsp;-1);&nbsp;<span class="comment">//对不等长的两个子表合并</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp&nbsp;=&nbsp;q;&nbsp;q&nbsp;=&nbsp;rf;&nbsp;rf&nbsp;=&nbsp;tmp;&nbsp;<span class="comment">//交换q,rf，以保证下一趟归并时，仍从q&nbsp;归并到rf</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span><span class="datatypes">int</span><span>&nbsp;main(){&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;a[10]&nbsp;=&nbsp;{3,1,5,7,2,4,9,6,10,8};&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;b[10];&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;MergeSort(a,&nbsp;b,&nbsp;10);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;print(b,10);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;<span class="string">"结果："</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;print(a,10);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre class="cpp" name="code" style="display: none;">void print(int a[], int n){
	for(int j= 0; j&lt;n; j++){
		cout&lt;&lt;a[j] &lt;&lt;"  ";
	}
	cout&lt;&lt;endl;
}

//将r[i…m]和r[m +1 …n]归并到辅助数组rf[i…n]
void Merge(ElemType *r,ElemType *rf, int i, int m, int n)
{
	int j,k;
	for(j=m+1,k=i; i&lt;=m &amp;&amp; j &lt;=n ; ++k){
		if(r[j] &lt; r[i]) rf[k] = r[j++];
		else rf[k] = r[i++];
	}
	while(i &lt;= m)  rf[k++] = r[i++];
	while(j &lt;= n)  rf[k++] = r[j++];
	print(rf,n+1);
}

void MergeSort(ElemType *r, ElemType *rf, int lenght)
{ 
	int len = 1;
	ElemType *q = r ;
	ElemType *tmp ;
	while(len &lt; lenght) {
		int s = len;
		len = 2 * s ;
		int i = 0;
		while(i+ len &lt;lenght){
			Merge(q, rf,  i, i+ s-1, i+ len-1 ); //对等长的两个子表合并
			i = i+ len;
		}
		if(i + s &lt; lenght){
			Merge(q, rf,  i, i+ s -1, lenght -1); //对不等长的两个子表合并
		}
		tmp = q; q = rf; rf = tmp; //交换q,rf，以保证下一趟归并时，仍从q 归并到rf
	}
}


int main(){
	int a[10] = {3,1,5,7,2,4,9,6,10,8};
	int b[10];
	MergeSort(a, b, 10);
	print(b,10);
	cout&lt;&lt;"结果：";
	print(a,10);

}</pre>
<br>
<p><strong><span style="color:#3333ff; font-size:16px">两路归并的递归算法</span></strong></p>
<div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><div style="position: absolute; left: 0px; top: 0px; width: 0px; height: 0px; z-index: 99;"><embed id="ZeroClipboardMovie_13" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="0" height="0" name="ZeroClipboardMovie_13" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=13&amp;width=0&amp;height=0" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="keyword">void</span><span>&nbsp;MSort(ElemType&nbsp;*r,&nbsp;ElemType&nbsp;*rf,</span><span class="datatypes">int</span><span>&nbsp;s,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;t)&nbsp;&nbsp;</span></span></li><li class=""><span>{&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;ElemType&nbsp;*rf2;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>(s==t)&nbsp;r[s]&nbsp;=&nbsp;rf[s];&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;m=(s+t)/2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">/*平分*p&nbsp;表*/</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MSort(r,&nbsp;rf2,&nbsp;s,&nbsp;m);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">/*递归地将p[s…m]归并为有序的p2[s…m]*/</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MSort(r,&nbsp;rf2,&nbsp;m+1,&nbsp;t);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">/*递归地将p[m+1…t]归并为有序的p2[m+1…t]*/</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Merge(rf2,&nbsp;rf,&nbsp;s,&nbsp;m+1,t);&nbsp;&nbsp;&nbsp;<span class="comment">/*将p2[s…m]和p2[m+1…t]归并到p1[s…t]*/</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li><li class="alt"><span><span class="keyword">void</span><span>&nbsp;MergeSort_recursive(ElemType&nbsp;*r,&nbsp;ElemType&nbsp;*rf,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;n)&nbsp;&nbsp;</span></span></li><li class=""><span>{&nbsp;&nbsp;&nbsp;<span class="comment">/*对顺序表*p&nbsp;作归并排序*/</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;MSort(r,&nbsp;rf,0,&nbsp;n-1);&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre class="cpp" name="code" style="display: none;">void MSort(ElemType *r, ElemType *rf,int s, int t)
{ 
	ElemType *rf2;
	if(s==t) r[s] = rf[s];
	else
	{ 
		int m=(s+t)/2;			/*平分*p 表*/
		MSort(r, rf2, s, m);		/*递归地将p[s…m]归并为有序的p2[s…m]*/
		MSort(r, rf2, m+1, t);		/*递归地将p[m+1…t]归并为有序的p2[m+1…t]*/
		Merge(rf2, rf, s, m+1,t);	/*将p2[s…m]和p2[m+1…t]归并到p1[s…t]*/
	}
}
void MergeSort_recursive(ElemType *r, ElemType *rf, int n)
{   /*对顺序表*p 作归并排序*/
	MSort(r, rf,0, n-1);
}</pre>
<h2 class="headline-1 bk-sidecatalog-title" style="border-bottom:rgb(222,223,225) 1px solid; text-align:left; padding-bottom:6px; line-height:26px; margin:0px 0px 10px; padding-left:0px; padding-right:0px; font-family:Arial; color:rgb(51,51,51); clear:both; padding-top:0px"><a name="t8"></a>
<span style="color:#336699"><span style="line-height:36px; font-size:21px">8. 桶排序/基数排序(Radix Sort)</span></span></h2>
<p style="text-indent:2em">说基数排序之前，我们先说桶排序：</p>
<p style="text-indent:2em"><span style="color:rgb(51,51,255)"><strong>基本思想：</strong></span>是将阵列分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递回方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。当要被排序的阵列内的数值是均匀分配的时候，桶排序使用线性时间（Θ（n））。但桶排序并不是 比较排序，他不受到 O(n log n) 下限的影响。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 简单来说，就是把数据分组，放在一个个的桶中，然后对每个桶里面的在进行排序。 &nbsp;<br>
</p>
<p></p>
<p style="text-indent:2em">&nbsp;例如要对大小为[1..1000]范围内的n个整数A[1..n]排序 &nbsp; </p>
<p style="text-indent:2em">&nbsp;首先，可以把桶设为大小为10的范围，具体而言，设集合B[1]存储[1..10]的整数，集合B[2]存储 &nbsp; (10..20]的整数，……集合B[i]存储( &nbsp; (i-1)*10, &nbsp; i*10]的整数，i &nbsp; = &nbsp; 1,2,..100。总共有&nbsp; 100个桶。 &nbsp;</p>
<p style="text-indent:2em">&nbsp; 然后，对A[1..n]从头到尾扫描一遍，把每个A[i]放入对应的桶B[j]中。&nbsp; 再对这100个桶中每个桶里的数字排序，这时可用冒泡，选择，乃至快排，一般来说任&nbsp; 何排序法都可以。</p>
<p style="text-indent:2em">&nbsp; 最后，依次输出每个桶里面的数字，且每个桶中的数字从小到大输出，这&nbsp; 样就得到所有数字排好序的一个序列了。 &nbsp;</p>
<p style="text-indent:2em">&nbsp; 假设有n个数字，有m个桶，如果数字是平均分布的，则每个桶里面平均有n/m个数字。如果 &nbsp; </p>
<p style="text-indent:2em">&nbsp; 对每个桶中的数字采用快速排序，那么整个算法的复杂度是 &nbsp; </p>
<p style="text-indent:2em">&nbsp; O(n&nbsp;&nbsp; + &nbsp; m &nbsp; * &nbsp; n/m*log(n/m)) &nbsp; = &nbsp; O(n&nbsp;&nbsp; + &nbsp; nlogn &nbsp; - &nbsp; nlogm) &nbsp;</p>
<p style="text-indent:2em">&nbsp; 从上式看出，当m接近n的时候，桶排序复杂度接近O(n) &nbsp; </p>
<p style="text-indent:2em">&nbsp; 当然，以上复杂度的计算是基于输入的n个数字是平均分布这个假设的。这个假设是很强的&nbsp; ，实际应用中效果并没有这么好。如果所有的数字都落在同一个桶中，那就退化成一般的排序了。&nbsp;&nbsp;</p>
<p><span style="white-space:pre"></span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 前面说的几大排序算法 ，大部分时间复杂度都是O（n2），也有部分排序算法时间复杂度是O(nlogn)。而桶式排序却能实现O（n）的时间复杂度。但桶排序的缺点是：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1）首先是空间复杂度比较高，需要的额外开销大。排序有两个数组的空间开销，一个存放待排序数组，一个就是所谓的桶，比如待排序值是从0到m-1，那就需要m个桶，这个桶数组就要至少m个空间。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2）其次待排序的元素都要在一定的范围内等等。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 桶式排序是一种分配排序。分配排序的特定是不需要进行关键码的比较，但前提是要知道待排序列的一些具体情况。</p>
<p><span style="color:#3333ff"><span style="font-size:12px"><strong><br>
</strong></span></span></p>
<p><span style="color:#3333ff"><span style="font-size:12px"><strong>分配排序的基本思想：<span style="color:#3333ff; background-color:rgb(255,204,0)"><span style="font-size:12px"><strong>说白了就是进行多次的桶式排序。</strong></span></span></strong></span></span></p>
<p><span style="color:#3333ff"><span style="font-size:12px">基数排序过程无须比较关键字，而是通过“分配”和“收集”过程来实现排序。它们的时间复杂度可达到线性阶：O(n)。</span><br>
</span></p>
<p><strong><span style="color:#3333ff; font-size:16px">实例:</span></strong></p>
<p>扑克牌中52 张牌，可按花色和面值分成两个字段，其大小关系为：<br>
花色： <strong><span style="color:#ff6600">梅花&lt; 方块&lt; 红心&lt; 黑心 &nbsp;<img alt="" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/1342855666_4899.jpg"></span></strong><br>
面值： <strong><span style="color:#ff6600">2 &lt; 3 &lt; 4 &lt; 5 &lt; 6 &lt; 7 &lt; 8 &lt; 9 &lt; 10 &lt; J &lt; Q &lt; K &lt; A</span></strong></p>
<p>若对扑克牌按花色、面值进行升序排序，得到如下序列：<br>
<img alt="" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/1342855525_3489.jpg"></p>
<p><img alt="" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/1342855538_2075.jpg"></p>
<p><br>
即两张牌，若花色不同，不论面值怎样，花色低的那张牌小于花色高的，只有在同花色情况下，大小关系才由面值的大小确定。这就是多关键码排序。</p>
<p>为得到排序结果，我们讨论两种排序方法。<br>
<strong><span style="color:#ff0000">方法1</span></strong>：先对花色排序，将其分为4 个组，即梅花组、方块组、红心组、黑心组。再对每个组分别按面值进行排序，最后，将4 个组连接起来即可。<br>
<span style="color:#ff0000"><strong>方法2</strong></span>：先按13 个面值给出13 个编号组(2 号，3 号，...，A 号)，将牌按面值依次放入对应的编号组，分成13 堆。再按花色给出4 个编号组(梅花、方块、红心、黑心)，将2号组中牌取出分别放入对应花色组，再将3 号组中牌取出分别放入对应花色组，……，这样，4 个花色组中均按面值有序，然后，将4 个花色组依次连接起来即可。</p>
<p>设n 个元素的待排序列包含d 个关键码{k1，k2，…，kd}，则称序列对关键码{k1，k2，…，kd}有序是指：对于序列中任两个记录r[i]和r[j](1≤i≤j≤n)都满足下列有序关系：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <img alt="" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/1342829730_4247.jpg"></p>
<p>其中k1 称为最主位关键码，kd 称为最次位关键码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;。</p>
<p>&nbsp;</p>
<p><span style="color:#3333ff; font-size:16px"><strong>两种多关键码排序方法：</strong></span></p>
<p>多关键码排序按照从最主位关键码到最次位关键码或从最次位到最主位关键码的顺序逐次排序，分两种方法：</p>
<p><span style="color:#ff6600">最高位优先(Most Significant Digit first)法，简称MSD 法</span>：</p>
<p>1）先按k1 排序<span style="color:#ff0000">分组</span>，将序列分成若干子序列，同一组序列的记录中，关键码k1 相等。</p>
<p>2）再对各组按k2 排序分成子组，之后，对后面的关键码继续这样的排序分组，直到按最次位关键码kd 对各子组排序后。</p>
<p>3）再将各组连接起来，便得到一个有序序列。扑克牌按花色、面值排序中介绍的方法一即是MSD 法。</p>
<p><span style="color:#ff6600">最低位优先(Least Significant Digit first)法，简称LSD 法</span>：</p>
<p>1) 先从kd 开始排序，再对kd-1进行排序，依次重复，直到按k1排序分组分成最小的子序列后。</p>
<p>2) 最后将各个子序列连接起来，便可得到一个有序的序列, 扑克牌按花色、面值排序中介绍的方法二即是LSD 法。</p>
<p><br>
</p>
<p><span style="color:#3333ff; font-size:16px"><strong>基于LSD方法的链式基数排序的基本思想</strong></span></p>
<p>　　“多关键字排序”的思想实现“单关键字排序”。对数字型或字符型的单关键字，可以看作由多个数位或多个字符构成的多关键字，此时可以采用“分配-收集”的方法进行排序，这一过程称作基数排序法，其中每个数字或字符可能的取值个数称为基数。比如，扑克牌的花色基数为4，面值基数为13。在整理扑克牌时，既可以先按花色整理，也可以先按面值整理。按花色整理时，先按红、黑、方、花的顺序分成4摞（分配），再按此顺序再叠放在一起（收集），然后按面值的顺序分成13摞（分配），再按此顺序叠放在一起（收集），如此进行二次分配和收集即可将扑克牌排列有序。&nbsp;
 &nbsp;</p>
<p><span style="color:#3333ff; font-size:16px">基数排序:</span></p>
<p>是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p>
<p><strong><span style="color:#3333ff; font-size:16px">算法实现：</span></strong></p>
<div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy</a><a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="About" title="?" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a><div style="position: absolute; left: 0px; top: 0px; width: 0px; height: 0px; z-index: 99;"><embed id="ZeroClipboardMovie_14" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="0" height="0" name="ZeroClipboardMovie_14" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=14&amp;width=0&amp;height=0" wmode="transparent"></div></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span>Void&nbsp;RadixSort(Node&nbsp;L[],length,maxradix)&nbsp;&nbsp;</span></span></li><li class=""><span>{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;m,n,k,lsp;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;k=1;m=1;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;temp[10][length-1];&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;Empty(temp);&nbsp;<span class="comment">//清空临时空间</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;<span class="keyword">while</span><span>(k&lt;maxradix)&nbsp;</span><span class="comment">//遍历所有关键字</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>(</span><span class="datatypes">int</span><span>&nbsp;i=0;i&lt;length;i++)&nbsp;</span><span class="comment">//分配过程</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>(L[i]&lt;m)&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Temp[0][n]=L[i];&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lsp=(L[i]/m)%10;&nbsp;<span class="comment">//确定关键字</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Temp[lsp][n]=L[i];&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n++;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;CollectElement(L,Temp);&nbsp;<span class="comment">//收集</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;n=0;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;m=m*10;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;k++;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre class="cpp" name="code" style="display: none;">Void RadixSort(Node L[],length,maxradix)
{
   int m,n,k,lsp;
   k=1;m=1;
   int temp[10][length-1];
   Empty(temp); //清空临时空间
   while(k&lt;maxradix) //遍历所有关键字
   {
     for(int i=0;i&lt;length;i++) //分配过程
    {
       if(L[i]&lt;m)
          Temp[0][n]=L[i];
       else
          Lsp=(L[i]/m)%10; //确定关键字
       Temp[lsp][n]=L[i];
       n++;
   }
   CollectElement(L,Temp); //收集
   n=0;
   m=m*10;
  k++;
 }
}</pre>
<br>
<br>
<p><br>
</p>
<p><br>
</p>
<p><br>
</p>
<p><span><span style="line-height:36px; font-size:21px"></span></span></p>
<h2 class="headline-1 bk-sidecatalog-title" style="border-bottom:rgb(222,223,225) 1px solid; text-align:left; padding-bottom:6px; line-height:26px; margin:0px 0px 10px; padding-left:0px; padding-right:0px; font-family:Arial; color:rgb(51,51,51); clear:both; padding-top:0px"><a name="t9"></a>
<span style="color:#336699"><span style="line-height:36px; font-size:21px">总结<br>
</span></span></h2>
<span></span>
<p class="pa-0"><span class="ca-2"><span style="color:#3333ff; font-size:16px"><strong>各种排序的稳定性，时间复杂度和空间复杂度总结：</strong></span></span></p>
<p class="pa-0"><span class="ca-2"><strong><img alt="" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/1342700879_2982.jpg"></strong></span></p>
<p>&nbsp;我们比较时间复杂度函数的情况：</p>
<p><img alt="" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/1342856655_3698.jpg"><br>
</p>
<p><br>
</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;时间复杂度函数O(n)的增长情况</p>
<p><img alt="" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/1342856728_5584.jpg"><br>
</p>
<p>所以对n较大的排序记录。一般的选择都是时间复杂度为<span lang="EN"><span style="font-family:&#39;Times New Roman&#39;">O(nlog2n)</span></span><span style="font-family:&#39;Times New Roman&#39;"><span style="font-family:宋体">的排序方法。</span></span></p>
<p><br>
</p>
<p><span style="color:#3333ff; font-size:16px"><strong>时间复杂度来说：</strong></span></p>
<p><span style="font-size:12px"><span lang="EN" style="font-family:宋体">(1)<span style="font:7pt ’Times New Roman’"></span></span><span style="font-family:宋体">平方阶<span lang="EN">(O(n</span></span><sup><span lang="EN" style="font-family:宋体">2</span></sup><span lang="EN" style="font-family:宋体">))排序</span></span><span style="font-family:宋体"><br>
<span style="font-family:Times New Roman; font-size:12px">　　各类简单排序:直接插入、直接选择和冒泡排序；</span><span lang="EN"><span style="font-family:Times New Roman; font-size:12px"><br>
</span></span></span><span lang="EN" style="font-family:宋体"><span style="font-family:Times New Roman"><span style="font-size:12px">&nbsp;(2)<span style="font:7pt ’Times New Roman’"></span></span></span></span><span style="font-family:宋体"><span style="font-family:Times New Roman; font-size:12px">线性对数阶</span><span lang="EN"><span style="font-family:Times New Roman; font-size:12px">(O(nlog2n))排序<br>
</span></span></span><span style="font-family:Times New Roman"><span style="font-size:12px"><span style="font-family:宋体">　　</span><span style="font-family:宋体">快速排序</span><span style="font-family:宋体">、</span><span style="font-family:宋体">堆排序</span><span style="font-family:宋体">和</span><span style="font-family:宋体">归并排序</span></span></span><span style="font-family:宋体"><span style="font-family:Times New Roman; font-size:12px">；</span><span lang="EN"><span style="font-family:Times New Roman; font-size:12px"><br>
</span></span></span><span lang="EN" style="font-family:宋体"><span style="font-family:Times New Roman"><span style="font-size:12px">&nbsp;(3)<span style="font:7pt ’Times New Roman’"></span></span></span></span><span lang="EN" style="font-family:宋体"><span style="font-family:Times New Roman; font-size:12px">O(n<sup>1+§</sup>))排序,</span></span><span style="font-family:宋体"><span style="font-family:Times New Roman; font-size:12px">§是介于</span><span lang="EN"><span style="font-family:Times New Roman; font-size:12px">0和1之间的常数。</span></span></span></p>
<p><span style="font-family:宋体"><span lang="EN"><span style="font-family:Times New Roman; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 希尔排序</span><span style="font-family:Times New Roman; font-size:12px"><br>
</span></span></span><span style="font-family:Times New Roman"><span style="font-size:12px"><span lang="EN" style="font-family:宋体">(4)<span style="font:7pt ’Times New Roman’"></span></span><span style="font-family:宋体">线性阶<span lang="EN">(O(n))排序</span></span></span></span><span style="font-family:宋体"><br>
<span style="font-family:Times New Roman"><span style="font-size:12px">　　基数排序，此外还有桶、箱排序。<span lang="EN"></span></span></span></span></p>
<p>说明：<span style="font-family:宋体"><span style="font-family:Times New Roman"><span style="font-size:12px"><span lang="EN"></span></span></span></span></p>
<span style="font-family:宋体"><span style="font-family:Times New Roman"><span style="font-size:12px"><span lang="EN"></span></span></span></span>
<p>当原表有序或基本有序时，直接插入排序和冒泡排序将大大减少比较次数和移动记录的次数，时间复杂度可降至<span style="font-family:Times New Roman">O</span>（<span style="font-family:Times New Roman">n</span>）；</p>
<p>而快速排序则相反，当原表基本有序时，将蜕化为冒泡排序，时间复杂度提高为<span style="font-family:Times New Roman">O</span>（<span style="font-family:Times New Roman">n2</span>）；</p>
<p>原表是否有序，对简单选择排序、堆排序、归并排序和基数排序的时间复杂度影响不大。</p>
&nbsp;
<p><strong><span style="color:#3333ff; font-size:16px">稳定性：</span></strong></p>
<p><span style="font-family:Tahoma,Verdana,STHeiTi,simsun,sans-serif; font-size:14px; color:#333333; line-height:19px; widows:2; text-transform:none; background-color:rgb(255,255,255); font-variant:normal; font-style:normal; text-indent:0px; display:inline!important; white-space:normal; orphans:2; float:none; letter-spacing:normal; font-weight:normal; word-spacing:0px"><span style="font-family:Tahoma,Verdana,STHeiTi,simsun,sans-serif; font-size:14px; color:#333333; line-height:19px; widows:2; text-transform:none; background-color:rgb(255,255,255); font-variant:normal; font-style:normal; text-indent:0px; display:inline!important; white-space:normal; orphans:2; float:none; letter-spacing:normal; font-weight:normal; word-spacing:0px">排序算法的稳定性:</span></span><span style="widows:2; text-transform:none; background-color:rgb(255,255,255); text-indent:0px; display:inline!important; font:14px/19px Tahoma,Verdana,STHeiTi,simsun,sans-serif; white-space:normal; orphans:2; float:none; letter-spacing:normal; color:#333333; word-spacing:0px"><span style="font-family:Tahoma,Verdana,STHeiTi,simsun,sans-serif; font-size:14px; color:#333333; line-height:19px; widows:2; text-transform:none; background-color:rgb(255,255,255); font-variant:normal; font-style:normal; text-indent:0px; display:inline!important; white-space:normal; orphans:2; float:none; letter-spacing:normal; font-weight:normal; word-spacing:0px">若待排序的序列中，<span style="color:#ff0000">存在多个具有相同关键字的记录</span>，经过排序，
 这些记录的相对次序保持不变，则称该算法是稳定的；若经排序后，记录的相对 次序发生了改变，则称该算法是不稳定的。<span>&nbsp;</span><br>
<span>&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#ff6600">稳定性的好处</span>：排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。基数排序就是这样，先按低位排序，逐次按高位排序，低位相同的元素其顺序再高位也相同时是不会改变的。另外，如果排序算法稳定，可以避免多余的比较；</span><br>
</span></span></p>
<p><span style="font-family:Tahoma,Verdana,STHeiTi,simsun,sans-serif; font-size:14px; color:#333333; line-height:19px; widows:2; text-transform:none; background-color:rgb(255,255,255); font-variant:normal; font-style:normal; text-indent:0px; display:inline!important; white-space:normal; orphans:2; float:none; letter-spacing:normal; font-weight:normal; word-spacing:0px"><span style="font-family:Tahoma,Verdana,STHeiTi,simsun,sans-serif; font-size:14px; color:#333333; line-height:19px; widows:2; text-transform:none; background-color:rgb(255,255,255); font-variant:normal; font-style:normal; text-indent:0px; display:inline!important; white-space:normal; orphans:2; float:none; letter-spacing:normal; font-weight:normal; word-spacing:0px">稳定的排序算法</span>：<span>冒泡排序、插入排序、归并排序和基数排序</span></span></p>
<p><span style="font-family:Tahoma,Verdana,STHeiTi,simsun,sans-serif; font-size:14px; color:#333333; line-height:19px; widows:2; text-transform:none; background-color:rgb(255,255,255); font-variant:normal; font-style:normal; text-indent:0px; display:inline!important; white-space:normal; orphans:2; float:none; letter-spacing:normal; font-weight:normal; word-spacing:0px"><span style="font-family:Tahoma,Verdana,STHeiTi,simsun,sans-serif; font-size:14px; color:#333333; line-height:19px; widows:2; text-transform:none; background-color:rgb(255,255,255); font-variant:normal; font-style:normal; text-indent:0px; display:inline!important; white-space:normal; orphans:2; float:none; letter-spacing:normal; font-weight:normal; word-spacing:0px">不是稳定的排序算法</span>：选择排序、快速排序、希尔排序、堆排序</span></p>
<p>&nbsp;</p>
<p><strong><span style="color:#3333ff; font-size:16px">选择排序算法准则：</span></strong></p>
<p><span style="font-size:12px"><span style="color:#000000">每种排序算法都各有优缺点。因此，在实用时需根据不同情况适当选用，甚至可以将多种方法结合起来使用。</span></span></p>
<p><span style="font-size:12px"><span style="color:#000000"><span lang="EN-US" style="font-size:12pt"><span style="font-size:12px">选择排序算法的依据</span></span></span></span></p>
<p><span style="font-size:12px">影响排序的因素有很多，平均时间复杂度低的算法并不一定就是最优的。相反，有时平均时间复杂度高的算法可能更适合某些特殊情况。同时，选择算法时还得考虑它的可读性，以利于软件的维护。一般而言，需要考虑的因素有以下四点：</span></p>
<p><span style="font-size:12px"><span style="font-family:Times New Roman">1</span>．待排序的记录数目<span style="font-family:Times New Roman">n</span>的大小；</span></p>
<p><span style="font-size:12px"><span style="font-family:Times New Roman">2</span>．记录本身数据量的大小，也就是记录中除关键字外的其他信息量的大小；</span></p>
<p><span style="font-size:12px"><span style="font-family:Times New Roman">3</span>．关键字的结构及其分布情况；</span></p>
<p><span style="font-size:12px"><span style="font-family:Times New Roman">4</span>．对排序稳定性的要求。</span></p>
<p><span style="color:#3333ff">设待排序元素的个数为n.</span></p>
<p><strong>1）</strong>当n较大，<span style="font-size:12px"><span style="font-family:宋体">则应采用时间复杂度为</span><span lang="EN"><span style="font-family:Times New Roman">O(nlog2n)</span></span></span><span style="font-family:Times New Roman"><span style="font-family:宋体; font-size:12px">的排序方法：快速排序、堆排序或归并排序序。</span></span></p>
<p><span style="font-family:宋体; font-size:12px">&nbsp;&nbsp; 快速排序：是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；</span><br>
<span lang="EN">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-family:宋体; font-size:12px">堆排序</span></span> ：&nbsp; 如果内存空间允许且要求稳定性的，</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-family:宋体; font-size:12px"><span style="font-family:Times New Roman">归并排序：它有一定数量的数据移动，所以我们可能过与插入排序组合，先获得一定长度的序列，然后再合并，在效率上将有所提高。</span></span></p>
<p><strong>2）</strong>&nbsp; 当n较大，内存空间允许，且要求稳定性 =》归并排序</p>
<p><strong>3）</strong>当n较小，<span style="font-family:宋体; font-size:12px">可采用直接插入或直接选择排序。</span></p>
<p>&nbsp;&nbsp;&nbsp; 直接插入排序：当元素分布有序，直接插入排序将大大减少比较次数和移动记录的次数。</p>
<p>&nbsp;&nbsp;&nbsp; 直接选择排序 ：元素分布有序，如果不要求稳定性，选择直接选择排序</p>
<p><strong>5）</strong>一般不使用或不直接使用传统的冒泡排序。</p>
<p><span style="font-family:Times New Roman"><span style="font-size:12px"><span lang="EN"><strong>6）</strong></span><span style="font-family:宋体">基数排序</span></span></span><span lang="EN"><br>
</span><span style="font-family:Times New Roman"><span style="font-size:12px"><span style="font-family:宋体">它是一种稳定的排序算法，但有一定的局限性：</span><br>
　　<span lang="EN">1</span><span style="font-family:宋体">、关键字可分解。</span></span></span><span lang="EN"><br>
<span style="font-size:12px"><span>　　</span>2</span></span><span style="font-family:Times New Roman"><span style="font-size:12px"><span style="font-family:宋体">、记录的关键字位数较少，如果密集更好<br>
</span><span lang="EN"><span>　　</span>3</span><span style="font-family:宋体">、如果是数字时，最好是无符号的，否则将增加相应的映射复杂度，可先将其正负分开排序。</span></span></span></p>
<p>&nbsp;</p>
注明：转载请提示出处：<a target="_blank" href="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET.htm">http://blog.csdn.net/hguisu/article/details/7776068</a>

</div>




<!-- Baidu Button BEGIN -->

<div class="bdsharebuttonbox bdshare-button-style0-16" style="float: right;" data-bd-bind="1413561251329">
<a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="bds_more" data-cmd="more" style="background-position:0 0 !important; background-image: url(http://bdimg.share.baidu.com/static/api/img/share/icons_0_16.png?v=d754dcc0.png) !important"></a>
<a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间" style="background-position:0 -52px !important"></a>
<a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博" style="background-position:0 -104px !important"></a>
<a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="bds_tqq" data-cmd="tqq" title="分享到腾讯微博" style="background-position:0 -260px !important"></a>
<a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="bds_renren" data-cmd="renren" title="分享到人人网" style="background-position:0 -208px !important"></a>
<a href="http://blog.csdn.net/hguisu/article/details/7776068#" class="bds_weixin" data-cmd="weixin" title="分享到微信" style="background-position:0 -1612px !important"></a>
</div>
<script>window._bd_share_config = { "common": { "bdSnsKey": {}, "bdText": "", "bdMini": "1", "bdMiniList": false, "bdPic": "", "bdStyle": "0", "bdSize": "16" }, "share": {} }; with (document) 0[(getElementsByTagName('head')[0] || body).appendChild(createElement('script')).src = 'http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=' + ~(-new Date() / 36e5)];</script>
<!-- Baidu Button END -->

<!--192.168.100.33-->
<ul class="article_next_prev">
            <li class="prev_article"><span onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_shangyipian&#39;]);location.href=&#39;/hguisu/article/details/7719428&#39;;">上一篇</span><a href="http://blog.csdn.net/hguisu/article/details/7719428" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_shangyipian&#39;])">图的应用详解-数据结构</a></li>
            <li class="next_article"><span onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_xiayipian&#39;]);location.href=&#39;/hguisu/article/details/7776091&#39;;">下一篇</span><a href="http://blog.csdn.net/hguisu/article/details/7776091" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_xiayipian&#39;])">查找 -数据结构</a></li>
</ul>

<!-- Baidu Button BEGIN -->
<script type="text/javascript" id="bdshare_js" data="type=tools&amp;uid=1536434" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/bds_s_v2.js"></script>

<script type="text/javascript">
    document.getElementById("bdshell_js").src = "http://bdimg.share.baidu.com/static/js/shell_v2.js?cdnversion=" + Math.ceil(new Date()/3600000)
</script>
<!-- Baidu Button END -->


        <div id="digg" articleid="7776068">
            <dl id="btnDigg" class="digg digg_disable">
                <dt onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_ding&#39;])">顶</dt>
                <dd>23</dd>
            </dl>
            <dl id="btnBury" class="digg digg_disable">
                <dt onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_cai&#39;])">踩</dt>
                <dd>0</dd>
            </dl>
        </div>
</div>
      <dl class="blog-associat-tag">
        <dt>主题推荐</dt>
        <dd>
                <a href="http://www.csdn.net/tag/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" target="_blank" class="blog-tage-red">排序算法</a> 
                <a href="http://www.csdn.net/tag/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95" target="_blank" class="blog-tage-red">递归算法</a> 
                <a href="http://www.csdn.net/tag/%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" class="blog-tage-red">二叉树</a> 
                <a href="http://www.csdn.net/tag/%E5%86%85%E5%AD%98" target="_blank" class="blog-tage-red">内存</a> 
                <a href="http://www.csdn.net/tag/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F" target="_blank" class="blog-tage-red">希尔排序</a> 
        </dd>
    </dl> 


<dl class="blog-ass-articl tracking-ad" data-mod="popu_36" id="res-relatived"> 
     <dt><span>猜你在找</span></dt>    
<dd style="background:url(http://static.blog.csdn.net/skin/default/images/blog-dot-red3.gif) no-repeat 0 10px;"><a href="http://blog.csdn.net/blue4689/article/details/6599592" title="moto &amp; google笔试题目-STL/C++面试题" strategy="CFRecommendAlgorithm" target="_blank">moto &amp; google笔试题目-STL/C++面试题</a></dd><dd style="background:url(http://static.blog.csdn.net/skin/default/images/blog-dot-red3.gif) no-repeat 0 10px;"><a href="http://blog.csdn.net/youxin2012/article/details/17083261" title="KMP算法原理与实现（精简）" strategy="CFRecommendAlgorithm" target="_blank">KMP算法原理与实现（精简）</a></dd><dd style="background:url(http://static.blog.csdn.net/skin/default/images/blog-dot-red3.gif) no-repeat 0 10px;"><a href="http://blog.csdn.net/xhu_eternalcc/article/details/22274489" title="C++学习之深入理解虚函数--虚函数表解析" strategy="CFRecommendAlgorithm" target="_blank">C++学习之深入理解虚函数--虚函数表解析</a></dd><dd style="background:url(http://static.blog.csdn.net/skin/default/images/blog-dot-red3.gif) no-repeat 0 10px;"><a href="http://blog.csdn.net/andycpp/article/details/8861549" title="“割绳子”的作者，你如此歧视、无视、鄙视中国人，这是何苦呢" strategy="CFRecommendAlgorithm" target="_blank">“割绳子”的作者，你如此歧视、无视、鄙视中国人，这是何苦呢</a></dd><dd style="background:url(http://static.blog.csdn.net/skin/default/images/blog-dot-red3.gif) no-repeat 0 10px;"><a href="http://blog.csdn.net/igiqoanw/article/details/38386815" title="面试经验" strategy="CFRecommendAlgorithm" target="_blank">面试经验</a></dd><dd style="background:url(http://static.blog.csdn.net/skin/default/images/blog-dot-red3.gif) no-repeat 0 10px;"><a href="http://blog.csdn.net/verticallimit/article/details/24826009" title="自己选择的路、跪着也要走完" strategy="CFRecommendAlgorithm" target="_blank">自己选择的路、跪着也要走完</a></dd><dd style="background:url(http://static.blog.csdn.net/skin/default/images/blog-dot-red3.gif) no-repeat 0 10px;"><a href="http://blog.csdn.net/zhangskd/article/details/7449476" title="TCP拥塞控制算法内核实现剖析（九）" strategy="CFRecommendAlgorithm" target="_blank">TCP拥塞控制算法内核实现剖析（九）</a></dd><dd style="background:url(http://static.blog.csdn.net/skin/default/images/blog-dot-red3.gif) no-repeat 0 10px;"><a href="http://blog.csdn.net/aeolus1019/article/details/7974430" title="Cannot make a static reference to the non-static method的解决方法" strategy="CFRecommendAlgorithm" target="_blank">Cannot make a static reference to the non-static method的解决方法</a></dd><dd style="background:url(http://static.blog.csdn.net/skin/default/images/blog-dot-red3.gif) no-repeat 0 10px;"><a href="http://blog.csdn.net/Stan1989/article/details/8589079" title="Machine Learning---LMS 算法" strategy="CFRecommendAlgorithm" target="_blank">Machine Learning---LMS 算法</a></dd><dd style="background:url(http://static.blog.csdn.net/skin/default/images/blog-dot-red3.gif) no-repeat 0 10px;"><a href="http://blog.csdn.net/sangni007/article/details/7680904" title="比微软kinect更强的视频跟踪算法--TLD跟踪算法介绍 ." strategy="CFRecommendAlgorithm" target="_blank">比微软kinect更强的视频跟踪算法--TLD跟踪算法介绍 .</a></dd></dl>

<script type="text/javascript">
    var searchtitletags = '八大排序算法' + ',' + '排序算法,递归算法,二叉树,内存,希尔排序';
    searchService({
        index: 'blog',
        query: searchtitletags,
        from: 10,
        size: 10,
        appendTo: '#res-relatived',
        url: 'recommend',
        his: 2,
        client: "blog_cf_enhance",
        tmpl: '<dd style="background:url(http://static.blog.csdn.net/skin/default/images/blog-dot-red3.gif) no-repeat 0 10px;"><a href="#{ url }" title="#{ title }" strategy="#{ strategy }">#{ title }</a></dd>'
    });

 </script>   


    <div id="ad_cen">
   
          <script type="text/javascript">
              new Ad(4, 'ad_cen');
          </script>
    <iframe id="ad_frm_0" frameborder="0" scrolling="no" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/ad(1).htm" style="border-width: 0px; overflow: hidden; width: 746px; height: 90px;"></iframe></div>
<div class="comment_class">
    <div id="comment_title" class="panel_head">
        <span class="see_comment">查看评论</span><a name="comments"></a></div>
    <div id="comment_list"><dl class="comment_item comment_topic" id="comment_item_4335159"><dt class="comment_head" floor="16">16楼 <span class="user"><a class="username" href="http://blog.csdn.net/cqu_software" target="_blank">cqu_software</a> <span class="ptime">2014-09-28 14:52发表</span>  <a href="http://blog.csdn.net/hguisu/article/details/7776068#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="4335159" username="cqu_software"> <a href="http://blog.csdn.net/hguisu/article/details/7776068#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/hguisu/article/details/7776068#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/cqu_software" target="_blank"><img src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/3_cqu_software.jpg" width="40" height="40"></a></dd><dd class="comment_body">标记，有用</dd></dl><dl class="comment_item comment_topic" id="comment_item_4331189"><dt class="comment_head" floor="15">15楼 <span class="user"><a class="username" href="http://blog.csdn.net/herojia_1" target="_blank">herojia_1</a> <span class="ptime">2014-09-27 16:29发表</span>  <a href="http://blog.csdn.net/hguisu/article/details/7776068#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="4331189" username="herojia_1"> <a href="http://blog.csdn.net/hguisu/article/details/7776068#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/hguisu/article/details/7776068#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/herojia_1" target="_blank"><img src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/3_herojia_1.jpg" width="40" height="40"></a></dd><dd class="comment_body">直接插入排序:<br>int j = i-2;<br>while( j&gt;=0 &amp;&amp; x &lt;a[ j ])<br>{}</dd></dl><dl class="comment_item comment_topic" id="comment_item_4324381"><dt class="comment_head" floor="14">14楼 <span class="user"><a class="username" href="http://blog.csdn.net/kee131" target="_blank">muyanchen4321</a> <span class="ptime">2014-09-25 18:03发表</span>  <a href="http://blog.csdn.net/hguisu/article/details/7776068#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="4324381" username="kee131"> <a href="http://blog.csdn.net/hguisu/article/details/7776068#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/hguisu/article/details/7776068#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/kee131" target="_blank"><img src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/3_kee131.jpg" width="40" height="40"></a></dd><dd class="comment_body">好老的帖子。。。<br>但是！<br>快排要重新将基准值插入中间位置<br><br>int partition(int a[], int low, int high)  <br>{  <br>    int privotKey = a[low];                             //基准元素  <br>    while(low &lt; high){                                   //从表的两端交替地向中间扫描  <br>        while(low &lt; high  &amp;&amp; a[high] &gt;= privotKey) --high;  //从high 所指位置向前搜索，至多到low+1 位置。将比基准元素小的交换到低端  <br>        swap(&amp;a[low], &amp;a[high]);  <br>        while(low &lt; high  &amp;&amp; a[low] &lt;= privotKey ) ++low;  <br>        swap(&amp;a[low], &amp;a[high]);  <br>    }  <br>    print(a,10);  <br>a[low] = privotKey;//快排要重新将基准值插入中间位置<br>    return low;  <br>}</dd></dl><dl class="comment_item comment_topic" id="comment_item_4318899"><dt class="comment_head" floor="13">13楼 <span class="user"><a class="username" href="http://blog.csdn.net/z81894371" target="_blank">风刮过冷</a> <span class="ptime">2014-09-24 13:39发表</span>  <a href="http://blog.csdn.net/hguisu/article/details/7776068#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="4318899" username="z81894371"> <a href="http://blog.csdn.net/hguisu/article/details/7776068#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/hguisu/article/details/7776068#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/z81894371" target="_blank"><img src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/3_z81894371.jpg" width="40" height="40"></a></dd><dd class="comment_body">很感谢博主，但不知道博主都一一试过这些算法没有,错误有点多啊，</dd><dl class="comment_item comment_reply" id="comment_item_4319109"><dt class="comment_head" floor="13">Re: <span class="user"><a class="username" href="http://blog.csdn.net/hguisu" target="_blank">真实的归宿</a> <span class="ptime">2014-09-24 14:41发表</span>  <a href="http://blog.csdn.net/hguisu/article/details/7776068#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="4319109" username="hguisu"> <a href="http://blog.csdn.net/hguisu/article/details/7776068#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/hguisu/article/details/7776068#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/hguisu" target="_blank"><img src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/3_hguisu.jpg" width="40" height="40"></a></dd><dd class="comment_body">回复z81894371：该博文总结《数据结构》提到的算法。但有的例子代码没有运行。</dd></dl></dl><dl class="comment_item comment_topic" id="comment_item_4283577"><dt class="comment_head" floor="12">12楼 <span class="user"><a class="username" href="http://blog.csdn.net/Quex_Jqx" target="_blank">Quex_Jqx</a> <span class="ptime">2014-09-16 14:44发表</span>  <a href="http://blog.csdn.net/hguisu/article/details/7776068#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="4283577" username="Quex_Jqx"> <a href="http://blog.csdn.net/hguisu/article/details/7776068#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/hguisu/article/details/7776068#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/Quex_Jqx" target="_blank"><img src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/3_quex_jqx.jpg" width="40" height="40"></a></dd><dd class="comment_body">很棒，收藏了</dd></dl><dl class="comment_item comment_topic" id="comment_item_4274249"><dt class="comment_head" floor="11">11楼 <span class="user"><a class="username" href="http://blog.csdn.net/jingjing123123jing" target="_blank">_小咖</a> <span class="ptime">2014-09-13 11:55发表</span>  <a href="http://blog.csdn.net/hguisu/article/details/7776068#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="4274249" username="jingjing123123jing"> <a href="http://blog.csdn.net/hguisu/article/details/7776068#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/hguisu/article/details/7776068#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/jingjing123123jing" target="_blank"><img src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/3_jingjing123123jing.jpg" width="40" height="40"></a></dd><dd class="comment_body">改进后的冒泡，感觉时间复杂度没有提升很多吧！<br>同样是  T(n) = n*(n+(n-1)+(n-2)+(n-3)+ ...+1)<br>O（n^2）<br>博主怎么看 ？</dd></dl><dl class="comment_item comment_topic" id="comment_item_4255435"><dt class="comment_head" floor="10">10楼 <span class="user"><a class="username" href="http://blog.csdn.net/lyg542133352" target="_blank">lyg542133352</a> <span class="ptime">2014-09-06 11:06发表</span>  <a href="http://blog.csdn.net/hguisu/article/details/7776068#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="4255435" username="lyg542133352"> <a href="http://blog.csdn.net/hguisu/article/details/7776068#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/hguisu/article/details/7776068#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/lyg542133352" target="_blank"><img src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/3_lyg542133352.jpg" width="40" height="40"></a></dd><dd class="comment_body">二元选择排序算法写错了！<br>我写了一个！博主看看<br>selectTwoSort(int a[],int n){<br>  int i;<br> for(i=0;i&lt;=n/2;i++){ // i从0开始，不然第一个数据，就没有参与比较<br>  int min = i;<br>  int max = n-i-1;//最大数据指针应该这么设置吧！<br>  int tmp = 0;<br>  int j;<br>  for(j= i+1;j&lt;n-i-1;j++){<br>   if(a[j]&lt;a[min]){<br>           min = j;<br>    continue;<br>   }<br>   if(a[j]&gt;a[max]){<br>    max = j;<br>   }<br>  }<br>  //放置最小值<br>  tmp = a[min];<br>  a[min] = a[i];<br>  a[i] = tmp;<br>  //放置最大值<br>  tmp= a[max];<br>  a[max]=a[n-i-1];<br>  a[n-i-1]=tmp;<br> }<br>}</dd><dl class="comment_item comment_reply" id="comment_item_4282763"><dt class="comment_head" floor="10">Re: <span class="user"><a class="username" href="http://blog.csdn.net/ye_scofield" target="_blank">ye_scofield</a> <span class="ptime">2014-09-16 10:12发表</span>  <a href="http://blog.csdn.net/hguisu/article/details/7776068#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="4282763" username="ye_scofield"> <a href="http://blog.csdn.net/hguisu/article/details/7776068#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/hguisu/article/details/7776068#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/ye_scofield" target="_blank"><img src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/3_ye_scofield.jpg" width="40" height="40"></a></dd><dd class="comment_body">回复lyg542133352：二元选择排序感觉还是错了，由于很难将清楚，也写了一篇博客http://blog.csdn.net/ye_scofield/article/details/39312717</dd><dl class="comment_item comment_reply" id="comment_item_4375523"><dt class="comment_head" floor="1">Re: <span class="user"><a class="username" href="http://blog.csdn.net/LSQ1020" target="_blank">焚稿</a> <span class="ptime">2014-10-08 12:11发表</span>  <a href="http://blog.csdn.net/hguisu/article/details/7776068#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="4375523" username="LSQ1020"> <a href="http://blog.csdn.net/hguisu/article/details/7776068#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/hguisu/article/details/7776068#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/LSQ1020" target="_blank"><img src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/3_lsq1020.jpg" width="40" height="40"></a></dd><dd class="comment_body">回复ye_scofield：的确有问题，二元选择排序没有考虑到：<br>一次选择时，最大值恰巧在队首的情况下，会出问题。<br>比如<br>int a[] = {60, 41 , 59 , 33, 58 };</dd></dl></dl></dl><dl class="comment_item comment_topic" id="comment_item_4218037"><dt class="comment_head" floor="9">9楼 <span class="user"><a class="username" href="http://blog.csdn.net/u010369532" target="_blank">Fokuso_Franklin</a> <span class="ptime">2014-08-27 17:39发表</span>  <a href="http://blog.csdn.net/hguisu/article/details/7776068#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="4218037" username="u010369532"> <a href="http://blog.csdn.net/hguisu/article/details/7776068#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/hguisu/article/details/7776068#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/u010369532" target="_blank"><img src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/3_u010369532.jpg" width="40" height="40"></a></dd><dd class="comment_body">受用了</dd></dl><dl class="comment_item comment_topic" id="comment_item_4215533"><dt class="comment_head" floor="8">8楼 <span class="user"><a class="username" href="http://blog.csdn.net/a86261566" target="_blank">Android新手-</a> <span class="ptime">2014-08-27 00:00发表</span>  <a href="http://blog.csdn.net/hguisu/article/details/7776068#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="4215533" username="a86261566"> <a href="http://blog.csdn.net/hguisu/article/details/7776068#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/hguisu/article/details/7776068#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/a86261566" target="_blank"><img src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/3_a86261566.jpg" width="40" height="40"></a></dd><dd class="comment_body">谢谢博主 图文并茂 获益匪浅</dd></dl><dl class="comment_item comment_topic" id="comment_item_4205359"><dt class="comment_head" floor="7">7楼 <span class="user"><a class="username" href="http://blog.csdn.net/seleron" target="_blank">程晨c</a> <span class="ptime">2014-08-23 09:31发表</span>  <a href="http://blog.csdn.net/hguisu/article/details/7776068#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="4205359" username="seleron"> <a href="http://blog.csdn.net/hguisu/article/details/7776068#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/hguisu/article/details/7776068#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/seleron" target="_blank"><img src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/3_seleron.jpg" width="40" height="40"></a></dd><dd class="comment_body">设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。” 这个改进方法是不是有问题呢？ <br>“pos位置之后的记录均已交换到位”这个是错误的。<br>假如 100,2,200,10,20 这样的数组，第一次循环冒泡后排序为 2,100,10,20,200 最后一次的交换位置在最后的位置， 那么下次排序并不能从本次的最后一个交换的位置开始</dd></dl><dl class="comment_item comment_topic" id="comment_item_4106113"><dt class="comment_head" floor="6">6楼 <span class="user"><a class="username" href="http://blog.csdn.net/huiguixian" target="_blank">huiguixian</a> <span class="ptime">2014-07-30 20:47发表</span>  <a href="http://blog.csdn.net/hguisu/article/details/7776068#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="4106113" username="huiguixian"> <a href="http://blog.csdn.net/hguisu/article/details/7776068#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/hguisu/article/details/7776068#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/huiguixian" target="_blank"><img src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/3_huiguixian.jpg" width="40" height="40"></a></dd><dd class="comment_body">太给力了，支持博主</dd></dl><dl class="comment_item comment_topic" id="comment_item_3026541"><dt class="comment_head" floor="5">5楼 <span class="user"><a class="username" href="http://blog.csdn.net/suzhouxueyuan" target="_blank">01世界里遨游</a> <span class="ptime">2013-10-25 16:05发表</span>  <a href="http://blog.csdn.net/hguisu/article/details/7776068#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="3026541" username="suzhouxueyuan"> <a href="http://blog.csdn.net/hguisu/article/details/7776068#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/hguisu/article/details/7776068#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/suzhouxueyuan" target="_blank"><img src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/3_suzhouxueyuan.jpg" width="40" height="40"></a></dd><dd class="comment_body">图文并茂,非常好.</dd></dl><dl class="comment_item comment_topic" id="comment_item_2912783"><dt class="comment_head" floor="4">4楼 <span class="user"><a class="username" href="http://blog.csdn.net/hzjdandan" target="_blank">hzjdandan</a> <span class="ptime">2013-09-12 14:16发表</span>  <a href="http://blog.csdn.net/hguisu/article/details/7776068#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2912783" username="hzjdandan"> <a href="http://blog.csdn.net/hguisu/article/details/7776068#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/hguisu/article/details/7776068#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/hzjdandan" target="_blank"><img src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/3_hzjdandan.jpg" width="40" height="40"></a></dd><dd class="comment_body">冒泡排序这句写错了<br>for(int j = i; j &lt; n-i-1; ++j) <br>应该是<br>for(int j = 0; j &lt; n-i-1; ++j)</dd><dl class="comment_item comment_reply" id="comment_item_2913437"><dt class="comment_head" floor="4">Re: <span class="user"><a class="username" href="http://blog.csdn.net/hguisu" target="_blank">真实的归宿</a> <span class="ptime">2013-09-12 16:53发表</span>  <a href="http://blog.csdn.net/hguisu/article/details/7776068#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2913437" username="hguisu"> <a href="http://blog.csdn.net/hguisu/article/details/7776068#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/hguisu/article/details/7776068#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/hguisu" target="_blank"><img src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/3_hguisu.jpg" width="40" height="40"></a></dd><dd class="comment_body">回复hzjdandan：确实是。</dd></dl></dl><dl class="comment_item comment_topic" id="comment_item_2654301"><dt class="comment_head" floor="3">3楼 <span class="user"><a class="username" href="http://blog.csdn.net/tlf1991" target="_blank">tlf1991</a> <span class="ptime">2013-06-04 21:25发表</span>  <a href="http://blog.csdn.net/hguisu/article/details/7776068#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2654301" username="tlf1991"> <a href="http://blog.csdn.net/hguisu/article/details/7776068#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/hguisu/article/details/7776068#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/tlf1991" target="_blank"><img src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/3_tlf1991.jpg" width="40" height="40"></a></dd><dd class="comment_body">二元选择排序 r[0]压根就没排啊</dd></dl><dl class="comment_item comment_topic" id="comment_item_2374618"><dt class="comment_head" floor="2">2楼 <span class="user"><a class="username" href="http://blog.csdn.net/Zhc1993" target="_blank">御风天</a> <span class="ptime">2012-09-17 19:59发表</span>  <a href="http://blog.csdn.net/hguisu/article/details/7776068#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2374618" username="Zhc1993"> <a href="http://blog.csdn.net/hguisu/article/details/7776068#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/hguisu/article/details/7776068#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/Zhc1993" target="_blank"><img src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/3_zhc1993.jpg" width="40" height="40"></a></dd><dd class="comment_body">直接插入算法<br>while( j&gt;=0 &amp;&amp; x &lt;a[ j ])<br>{}</dd><dl class="comment_item comment_reply" id="comment_item_4170427"><dt class="comment_head" floor="2">Re: <span class="user"><a class="username" href="http://blog.csdn.net/chuzhiyan" target="_blank">楚之烟</a> <span class="ptime">2014-08-13 21:16发表</span>  <a href="http://blog.csdn.net/hguisu/article/details/7776068#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="4170427" username="chuzhiyan"> <a href="http://blog.csdn.net/hguisu/article/details/7776068#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/hguisu/article/details/7776068#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/chuzhiyan" target="_blank"><img src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/3_chuzhiyan.jpg" width="40" height="40"></a></dd><dd class="comment_body">回复Zhc1993：+1</dd><dl class="comment_item comment_reply" id="comment_item_4204351"><dt class="comment_head" floor="1">Re: <span class="user"><a class="username" href="http://blog.csdn.net/FlyingTheDay" target="_blank">whisshen</a> <span class="ptime">2014-08-22 20:16发表</span>  <a href="http://blog.csdn.net/hguisu/article/details/7776068#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="4204351" username="FlyingTheDay"> <a href="http://blog.csdn.net/hguisu/article/details/7776068#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/hguisu/article/details/7776068#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/FlyingTheDay" target="_blank"><img src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/3_flyingtheday.jpg" width="40" height="40"></a></dd><dd class="comment_body">回复chuzhiyan：+1</dd><dl class="comment_item comment_reply" id="comment_item_4329431"><dt class="comment_head" floor="1">Re: <span class="user"><a class="username" href="http://blog.csdn.net/zt1006840145" target="_blank">zt1006840145</a> <span class="ptime">2014-09-27 00:43发表</span>  <a href="http://blog.csdn.net/hguisu/article/details/7776068#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="4329431" username="zt1006840145"> <a href="http://blog.csdn.net/hguisu/article/details/7776068#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/hguisu/article/details/7776068#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/zt1006840145" target="_blank"><img src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/3_zt1006840145.jpg" width="40" height="40"></a></dd><dd class="comment_body">回复FlyingTheDay：+1</dd></dl></dl></dl></dl><dl class="comment_item comment_topic" id="comment_item_2374327"><dt class="comment_head" floor="1">1楼 <span class="user"><a class="username" href="http://blog.csdn.net/Zhc1993" target="_blank">御风天</a> <span class="ptime">2012-09-17 16:06发表</span>  <a href="http://blog.csdn.net/hguisu/article/details/7776068#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2374327" username="Zhc1993"> <a href="http://blog.csdn.net/hguisu/article/details/7776068#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/hguisu/article/details/7776068#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/Zhc1993" target="_blank"><img src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/3_zhc1993.jpg" width="40" height="40"></a></dd><dd class="comment_body">good</dd></dl><div class="clear"></div></div>
    <div id="comment_bar" style="display: none;">
    </div>
    <div id="comment_form"><div class="guest_link">您还没有登录,请<a href="javascript:void(0);" onclick="javascript:csdn.showLogin(function (dat) {js_logined(dat.data.userName);});">[登录]</a>或<a href="http://passport.csdn.net/account/register?from=http%3A%2F%2Fblog.csdn.net%2Fhguisu%2Farticle%2Fdetails%2F7776068">[注册]</a></div></div>

    <div class="announce">
        * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场<a name="reply"></a><a name="quote"></a></div>
</div>

<script type="text/javascript">
    var fileName = '7776068';
    var commentscount = 23;
    var islock = false
</script>
<script type="text/javascript" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/comment.js"></script>
    <div id="ad_bot">
    <iframe id="ad_frm_1" frameborder="0" scrolling="no" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/ad(2).htm" style="border-width: 0px; overflow: hidden; width: 746px; height: 0px;"></iframe></div>
    <script type="text/javascript">
    new Ad(5, 'ad_bot');
    </script>
<div id="report_dialog">
</div>

<div id="d-top" style="bottom:60px;">
      

       <a id="quick-reply" class="btn btn-top q-reply" title="快速回复" style="display:none;">
            <img src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/blog-icon-reply.png" alt="快速回复">
        </a>    

    <a id="d-top-a" class="btn btn-top backtop" style="" title="返回顶部" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_huidaodingbu&#39;])">         
         <img src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/top.png" alt="TOP">
    </a>
</div>
<script type="text/javascript">
    $(function ()
    {
        $("#ad_frm_0").height("90px");
        
        setTimeout(function(){
            $("#ad_frm_2").height("200px");
        },1000);
        

        if($("#comment_content").length>0)
        {
            $("#quick-reply").show();

            $("#quick-reply").click(function(){
                setEditorFocus();
            });
        }       
     
        var d_top = $('#d-top-a');
        document.onscroll = function ()
        {
            var scrTop = (document.body.scrollTop || document.documentElement.scrollTop);
            if (scrTop > 500)
            {
                d_top.show();
            } else
            {
                d_top.hide();
            }
        }
        $('#d-top-a').click(function ()
        {
            scrollTo(0, 0);
            this.blur();
            return false;
        });
    });
  
</script>
<style type="text/css">
    .tag_list
    {
        background: none repeat scroll 0 0 #FFFFFF;
        border: 1px solid #D7CBC1;
        color: #000000;
        font-size: 12px;
        line-height: 20px;
        list-style: none outside none;
        margin: 10px 2% 0 1%;
        padding: 1px;
    }
    .tag_list h5
    {
        background: none repeat scroll 0 0 #E0DBD3;
        color: #47381C;
        font-size: 12px;
        height: 24px;
        line-height: 24px;
        padding: 0 5px;
        margin: 0;
    }
    .tag_list h5 a
    {
        color: #47381C;
    }
    .classify
    {
        margin: 10px 0;
        padding: 4px 12px 8px;
    }
    .classify a
    {
        margin-right: 20px;
        white-space: nowrap;
    }
</style>
<div class="tag_list">
    <h5>
        <a href="http://www.csdn.net/tag/" target="_blank">核心技术类目</a></h5>
    <div class="classify">
<a title="全部主题" href="http://www.csdn.net/tag" target="_blank" onclick="LogClickCount(this,336);">全部主题</a>
<a title="Hadoop" href="http://g.csdn.net/5272865" target="_blank" onclick="LogClickCount(this,336);">Hadoop</a>
<a title="AWS" href="http://g.csdn.net/5272866" target="_blank" onclick="LogClickCount(this,336);">AWS</a>
<a title="移动游戏" href="http://g.csdn.net/5272870" target="_blank" onclick="LogClickCount(this,336);">移动游戏</a>
<a title="Java" href="http://g.csdn.net/5272871" target="_blank" onclick="LogClickCount(this,336);">Java</a>
<a title="Android" href="http://g.csdn.net/5272872" target="_blank" onclick="LogClickCount(this,336);">Android</a>
<a title="iOS" href="http://g.csdn.net/5272873" target="_blank" onclick="LogClickCount(this,336);">iOS</a>
<a title="Swift" href="http://g.csdn.net/5272868" target="_blank" onclick="LogClickCount(this,336);">Swift</a>
<a title="智能硬件" href="http://g.csdn.net/5272869" target="_blank" onclick="LogClickCount(this,336);">智能硬件</a>
<a title="Docker" href="http://g.csdn.net/5272867" target="_blank" onclick="LogClickCount(this,336);">Docker</a>
<a title="OpenStack" href="http://g.csdn.net/5272925" target="_blank" onclick="LogClickCount(this,336);">OpenStack</a>
<a title="VPN" href="http://www.csdn.net/tag/vpn" target="_blank" onclick="LogClickCount(this,336);">VPN</a>
<a title="Spark" href="http://g.csdn.net/5272924" target="_blank" onclick="LogClickCount(this,336);">Spark</a>
<a title="ERP" href="http://www.csdn.net/tag/erp" target="_blank" onclick="LogClickCount(this,336);">ERP</a>
<a title="IE10" href="http://www.csdn.net/tag/ie10" target="_blank" onclick="LogClickCount(this,336);">IE10</a>
<a title="Eclipse" href="http://www.csdn.net/tag/eclipse" target="_blank" onclick="LogClickCount(this,336);">Eclipse</a>
<a title="CRM" href="http://www.csdn.net/tag/crm" target="_blank" onclick="LogClickCount(this,336);">CRM</a>
<a title="JavaScript" href="http://www.csdn.net/tag/javascript" target="_blank" onclick="LogClickCount(this,336);">JavaScript</a>
<a title="数据库" href="http://www.csdn.net/tag/%E6%95%B0%E6%8D%AE%E5%BA%93" target="_blank" onclick="LogClickCount(this,336);">数据库</a>
<a title="Ubuntu" href="http://www.csdn.net/tag/ubuntu" target="_blank" onclick="LogClickCount(this,336);">Ubuntu</a>
<a title="NFC" href="http://www.csdn.net/tag/nfc" target="_blank" onclick="LogClickCount(this,336);">NFC</a>
<a title="WAP" href="http://www.csdn.net/tag/wap" target="_blank" onclick="LogClickCount(this,336);">WAP</a>
<a title="jQuery" href="http://www.csdn.net/tag/jquery" target="_blank" onclick="LogClickCount(this,336);">jQuery</a>
<a title="BI" href="http://www.csdn.net/tag/bi" target="_blank" onclick="LogClickCount(this,336);">BI</a>
<a title="HTML5" href="http://www.csdn.net/tag/html5" target="_blank" onclick="LogClickCount(this,336);">HTML5</a>
<a title="Spring" href="http://www.csdn.net/tag/spring" target="_blank" onclick="LogClickCount(this,336);">Spring</a>
<a title="Apache" href="http://www.csdn.net/tag/apache" target="_blank" onclick="LogClickCount(this,336);">Apache</a>
<a title=".NET" href="http://www.csdn.net/tag/.net" target="_blank" onclick="LogClickCount(this,336);">.NET</a>
<a title="API" href="http://www.csdn.net/tag/api" target="_blank" onclick="LogClickCount(this,336);">API</a>
<a title="HTML" href="http://www.csdn.net/tag/html" target="_blank" onclick="LogClickCount(this,336);">HTML</a>
<a title="SDK" href="http://www.csdn.net/tag/sdk" target="_blank" onclick="LogClickCount(this,336);">SDK</a>
<a title="IIS" href="http://www.csdn.net/tag/iis" target="_blank" onclick="LogClickCount(this,336);">IIS</a>
<a title="Fedora" href="http://www.csdn.net/tag/fedora" target="_blank" onclick="LogClickCount(this,336);">Fedora</a>
<a title="XML" href="http://www.csdn.net/tag/xml" target="_blank" onclick="LogClickCount(this,336);">XML</a>
<a title="LBS" href="http://www.csdn.net/tag/lbs" target="_blank" onclick="LogClickCount(this,336);">LBS</a>
<a title="Unity" href="http://www.csdn.net/tag/unity" target="_blank" onclick="LogClickCount(this,336);">Unity</a>
<a title="Splashtop" href="http://www.csdn.net/tag/splashtop" target="_blank" onclick="LogClickCount(this,336);">Splashtop</a>
<a title="UML" href="http://www.csdn.net/tag/uml" target="_blank" onclick="LogClickCount(this,336);">UML</a>
<a title="components" href="http://www.csdn.net/tag/components" target="_blank" onclick="LogClickCount(this,336);">components</a>
<a title="Windows Mobile" href="http://www.csdn.net/tag/windowsmobile" target="_blank" onclick="LogClickCount(this,336);">Windows Mobile</a>
<a title="Rails" href="http://www.csdn.net/tag/rails" target="_blank" onclick="LogClickCount(this,336);">Rails</a>
<a title="QEMU" href="http://www.csdn.net/tag/qemu" target="_blank" onclick="LogClickCount(this,336);">QEMU</a>
<a title="KDE" href="http://www.csdn.net/tag/kde" target="_blank" onclick="LogClickCount(this,336);">KDE</a>
<a title="Cassandra" href="http://www.csdn.net/tag/cassandra" target="_blank" onclick="LogClickCount(this,336);">Cassandra</a>
<a title="CloudStack" href="http://www.csdn.net/tag/cloudstack" target="_blank" onclick="LogClickCount(this,336);">CloudStack</a>
<a title="FTC" href="http://www.csdn.net/tag/ftc" target="_blank" onclick="LogClickCount(this,336);">FTC</a>
<a title="coremail" href="http://www.csdn.net/tag/coremail" target="_blank" onclick="LogClickCount(this,336);">coremail</a>
<a title="OPhone " href="http://www.csdn.net/tag/ophone" target="_blank" onclick="LogClickCount(this,336);">OPhone </a>
<a title="CouchBase" href="http://www.csdn.net/tag/couchbase" target="_blank" onclick="LogClickCount(this,336);">CouchBase</a>
<a title="云计算" href="http://www.csdn.net/tag/%E4%BA%91%E8%AE%A1%E7%AE%97" target="_blank" onclick="LogClickCount(this,336);">云计算</a>
<a title="iOS6" href="http://www.csdn.net/tag/iOS6" target="_blank" onclick="LogClickCount(this,336);">iOS6</a>
<a title="Rackspace " href="http://www.csdn.net/tag/rackspace" target="_blank" onclick="LogClickCount(this,336);">Rackspace </a>
<a title="Web App" href="http://www.csdn.net/tag/webapp" target="_blank" onclick="LogClickCount(this,336);">Web App</a>
<a title="SpringSide" href="http://www.csdn.net/tag/springside" target="_blank" onclick="LogClickCount(this,336);">SpringSide</a>
<a title="Maemo" href="http://www.csdn.net/tag/maemo" target="_blank" onclick="LogClickCount(this,336);">Maemo</a>
<a title="Compuware" href="http://www.csdn.net/tag/compuware" target="_blank" onclick="LogClickCount(this,336);">Compuware</a>
<a title="大数据" href="http://www.csdn.net/tag/%E5%A4%A7%E6%95%B0%E6%8D%AE" target="_blank" onclick="LogClickCount(this,336);">大数据</a>
<a title="aptech" href="http://www.csdn.net/tag/aptech" target="_blank" onclick="LogClickCount(this,336);">aptech</a>
<a title="Perl" href="http://www.csdn.net/tag/perl" target="_blank" onclick="LogClickCount(this,336);">Perl</a>
<a title="Tornado" href="http://www.csdn.net/tag/tornado" target="_blank" onclick="LogClickCount(this,336);">Tornado</a>
<a title="Ruby" href="http://www.csdn.net/tag/ruby" target="_blank" onclick="LogClickCount(this,336);">Ruby</a>
<a title="Hibernate" href="http://www.csdn.net/hibernate" target="_blank" onclick="LogClickCount(this,336);">Hibernate</a>
<a title="ThinkPHP" href="http://www.csdn.net/tag/thinkphp" target="_blank" onclick="LogClickCount(this,336);">ThinkPHP</a>
<a title="HBase" href="http://www.csdn.net/tag/hbase" target="_blank" onclick="LogClickCount(this,336);">HBase</a>
<a title="Pure" href="http://www.csdn.net/tag/pure" target="_blank" onclick="LogClickCount(this,336);">Pure</a>
<a title="Solr" href="http://www.csdn.net/tag/solr" target="_blank" onclick="LogClickCount(this,336);">Solr</a>
<a title="Angular" href="http://www.csdn.net/tag/angular" target="_blank" onclick="LogClickCount(this,336);">Angular</a>
<a title="Cloud Foundry" href="http://www.csdn.net/tag/cloudfoundry" target="_blank" onclick="LogClickCount(this,336);">Cloud Foundry</a>
<a title="Redis" href="http://www.csdn.net/tag/redis" target="_blank" onclick="LogClickCount(this,336);">Redis</a>
<a title="Scala" href="http://www.csdn.net/tag/scala" target="_blank" onclick="LogClickCount(this,336);">Scala</a>
<a title="Django" href="http://www.csdn.net/tag/django" target="_blank" onclick="LogClickCount(this,336);">Django</a>
<a title="Bootstrap" href="http://www.csdn.net/tag/bootstrap" target="_blank" onclick="LogClickCount(this,336);">Bootstrap</a>
    </div>
</div>


                        <div class="clear">
                        </div>
                    </div>                   
                
            </div>
            <div id="side">
    <div class="side">
<div id="panel_Profile" class="panel">
<ul class="panel_head"><span>个人资料</span></ul>
<ul class="panel_body profile">
<div id="blog_userface">
    <a href="http://my.csdn.net/hguisu" target="_blank">
    <img src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/1_hguisu.jpg" title="访问我的空间" style="max-width:90%">
    </a>
    <br>
    <span><a href="http://my.csdn.net/hguisu" class="user_name" target="_blank">真实的归宿</a></span>
</div>
<div class="interact">
<a href="javascript:void(0);" class="attent" id="span_add_follow" title="[加关注]" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_guanzhu&#39;])"></a>

 <a href="javascript:void(0);" class="letter" title="[发私信]" onclick="window.open(&#39;http://msg.csdn.net/letters/model?receiver=hguisu&#39;,&#39;_blank&#39;,&#39;height=350,width=700&#39;);_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_sixin&#39;])"></a>  
</div>
<div id="blog_medal">
<div id="bms_box"><a href="http://medal.blog.csdn.net/allmedal.aspx" target="_blank"><img src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/holdon_s2.gif" onmouseover="m_over_m(this,0)" onmouseout="m_out_m()" alt=""></a></div></div>
<ul id="blog_rank">
    <li>访问：<span>1251126次</span></li>
    <li>积分：<span>12171分</span></li>
    <li>排名：<span>第310名</span></li>
</ul>
<ul id="blog_statistics">
    <li>原创：<span>202篇</span></li>
    <li>转载：<span>0篇</span></li>
    <li>译文：<span>0篇</span></li>
    <li>评论：<span>618条</span></li>
</ul>
</ul>
</div>


<div id="panel_Category" class="panel">
<ul class="panel_head"><span>文章分类</span></ul>
<ul class="panel_body">
             <li>
                <a href="http://blog.csdn.net/hguisu/article/category/1253451" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">操作系统</a><span>(5)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/hguisu/article/category/796967" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">Linux</a><span>(17)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/hguisu/article/category/796963" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">MySQL</a><span>(12)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/hguisu/article/category/796962" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">PHP</a><span>(41)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/hguisu/article/category/1104862" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">PHP内核</a><span>(11)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/hguisu/article/category/796968" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">技术人生</a><span>(7)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/hguisu/article/category/1054628" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">数据结构与算法</a><span>(29)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/hguisu/article/category/1072794" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">云计算hadoop</a><span>(24)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/hguisu/article/category/1075597" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">网络知识</a><span>(7)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/hguisu/article/category/1080443" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">c/c++</a><span>(23)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/hguisu/article/category/1099674" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">memcache</a><span>(5)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/hguisu/article/category/1111071" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">HipHop</a><span>(2)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/hguisu/article/category/1112019" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">计算机原理</a><span>(4)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/hguisu/article/category/1114530" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">Java</a><span>(7)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/hguisu/article/category/1122753" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">socket网络编程</a><span>(8)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/hguisu/article/category/1133340" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">设计模式</a><span>(26)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/hguisu/article/category/1151353" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">AOP</a><span>(2)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/hguisu/article/category/1152364" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">重构</a><span>(11)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/hguisu/article/category/1173389" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">重构与模式</a><span>(1)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/hguisu/article/category/1209788" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">大数据处理</a><span>(12)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/hguisu/article/category/1230933" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">搜索引擎Search Engine</a><span>(15)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/hguisu/article/category/1302430" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">HTML5</a><span>(1)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/hguisu/article/category/1309674" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">Android</a><span>(1)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/hguisu/article/category/1422000" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">webserver</a><span>(3)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/hguisu/article/category/1429288" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">NOSQL</a><span>(7)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/hguisu/article/category/1825837" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">NOSQL Mongo</a><span>(0)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/hguisu/article/category/1868795" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">分布式</a><span>(1)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/hguisu/article/category/2065283" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">数据结构与算法  xi</a><span>(0)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/hguisu/article/category/2065287" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">协议</a><span>(1)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/hguisu/article/category/2294375" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">信息论的熵</a><span>(0)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/hguisu/article/category/2482451" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">关于php的libevent扩展的应用</a><span>(0)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/hguisu/article/category/2482459" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">libevent简单介绍</a><span>(0)</span>
            </li>
</ul>
</div><div id="panel_Archive" class="panel">
<ul class="panel_head"><span>文章存档</span></ul>
<ul class="panel_body">
<div id="archive_list"><li><a href="http://blog.csdn.net/hguisu/article/month/2014/09">2014年09月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/hguisu/article/month/2014/08">2014年08月</a><span>(2)</span></li><li><a href="http://blog.csdn.net/hguisu/article/month/2014/05">2014年05月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/hguisu/article/month/2014/03">2014年03月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/hguisu/article/month/2014/02">2014年02月</a><span>(1)</span></li><span class="hidelist" style="display:none;"><li><a href="http://blog.csdn.net/hguisu/article/month/2014/01">2014年01月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/hguisu/article/month/2013/12">2013年12月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/hguisu/article/month/2013/10">2013年10月</a><span>(2)</span></li><li><a href="http://blog.csdn.net/hguisu/article/month/2013/09">2013年09月</a><span>(2)</span></li><li><a href="http://blog.csdn.net/hguisu/article/month/2013/08">2013年08月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/hguisu/article/month/2013/07">2013年07月</a><span>(2)</span></li><li><a href="http://blog.csdn.net/hguisu/article/month/2013/06">2013年06月</a><span>(3)</span></li><li><a href="http://blog.csdn.net/hguisu/article/month/2013/05">2013年05月</a><span>(3)</span></li><li><a href="http://blog.csdn.net/hguisu/article/month/2013/03">2013年03月</a><span>(3)</span></li><li><a href="http://blog.csdn.net/hguisu/article/month/2013/02">2013年02月</a><span>(2)</span></li><li><a href="http://blog.csdn.net/hguisu/article/month/2013/01">2013年01月</a><span>(2)</span></li><li><a href="http://blog.csdn.net/hguisu/article/month/2012/12">2012年12月</a><span>(4)</span></li><li><a href="http://blog.csdn.net/hguisu/article/month/2012/11">2012年11月</a><span>(3)</span></li><li><a href="http://blog.csdn.net/hguisu/article/month/2012/10">2012年10月</a><span>(2)</span></li><li><a href="http://blog.csdn.net/hguisu/article/month/2012/09">2012年09月</a><span>(15)</span></li><li><a href="http://blog.csdn.net/hguisu/article/month/2012/08">2012年08月</a><span>(6)</span></li><li><a href="http://blog.csdn.net/hguisu/article/month/2012/07">2012年07月</a><span>(8)</span></li><li><a href="http://blog.csdn.net/hguisu/article/month/2012/06">2012年06月</a><span>(14)</span></li><li><a href="http://blog.csdn.net/hguisu/article/month/2012/05">2012年05月</a><span>(29)</span></li><li><a href="http://blog.csdn.net/hguisu/article/month/2012/04">2012年04月</a><span>(26)</span></li><li><a href="http://blog.csdn.net/hguisu/article/month/2012/03">2012年03月</a><span>(27)</span></li><li><a href="http://blog.csdn.net/hguisu/article/month/2012/02">2012年02月</a><span>(18)</span></li><li><a href="http://blog.csdn.net/hguisu/article/month/2011/12">2011年12月</a><span>(7)</span></li><li><a href="http://blog.csdn.net/hguisu/article/month/2011/01">2011年01月</a><span>(8)</span></li><li><a href="http://blog.csdn.net/hguisu/article/month/2010/07">2010年07月</a><span>(6)</span></li><li><a href="http://blog.csdn.net/hguisu/article/month/2007/12">2007年12月</a><span>(2)</span></li></span><div id="archive_list_button" class="list_closed">展开</div></div>
</ul>
</div>
<div id="hotarticls" class="panel">
<ul class="panel_head">
    <span>       
阅读排行    </span>
</ul>

<ul class="panel_body itemlist">
<li>
<a href="http://blog.csdn.net/hguisu/article/details/7244413" title="hbase安装配置（整合到hadoop）">hbase安装配置（整合到hadoop）</a><span>(51960)</span>
</li>
<li>
<a href="http://blog.csdn.net/hguisu/article/details/7453390" title="socket阻塞与非阻塞，同步与异步、I/O模型">socket阻塞与非阻塞，同步与异步、I/O模型</a><span>(45077)</span>
</li>
<li>
<a href="http://blog.csdn.net/hguisu/article/details/7237395" title="Hadoop集群配置（最全面总结）">Hadoop集群配置（最全面总结）</a><span>(39846)</span>
</li>
<li>
<a href="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET.htm" title="八大排序算法">八大排序算法</a><span>(36489)</span>
</li>
<li>
<a href="http://blog.csdn.net/hguisu/article/details/7558249" title="设计模式 ( 十八 ) 策略模式Strategy（对象行为型）">设计模式 ( 十八 ) 策略模式Strategy（对象行为型）</a><span>(30031)</span>
</li>
<li>
<a href="http://blog.csdn.net/hguisu/article/details/7527842" title="设计模式（五）适配器模式Adapter（结构型）">设计模式（五）适配器模式Adapter（结构型）</a><span>(26096)</span>
</li>
<li>
<a href="http://blog.csdn.net/hguisu/article/details/5731880" title="Mysql 多表联合查询效率分析及优化">Mysql 多表联合查询效率分析及优化</a><span>(25177)</span>
</li>
<li>
<a href="http://blog.csdn.net/hguisu/article/details/7418161" title="Java输入输出流">Java输入输出流</a><span>(25118)</span>
</li>
<li>
<a href="http://blog.csdn.net/hguisu/article/details/7996185" title="PageRank算法">PageRank算法</a><span>(24985)</span>
</li>
<li>
<a href="http://blog.csdn.net/hguisu/article/details/7244991" title="谷歌三大核心技术（三）Google BigTable中文版">谷歌三大核心技术（三）Google BigTable中文版</a><span>(21163)</span>
</li>
</ul>
</div>
<div id="hotarticls2" class="panel">
<ul class="panel_head"><span>评论排行</span></ul>
<ul class="panel_body itemlist">
<li>
<a href="http://blog.csdn.net/hguisu/article/details/7558249" title="设计模式 ( 十八 ) 策略模式Strategy（对象行为型）">设计模式 ( 十八 ) 策略模式Strategy（对象行为型）</a><span>(34)</span>
</li>
<li>
<a href="http://blog.csdn.net/hguisu/article/details/7453390" title="socket阻塞与非阻塞，同步与异步、I/O模型">socket阻塞与非阻塞，同步与异步、I/O模型</a><span>(34)</span>
</li>
<li>
<a href="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET.htm" title="八大排序算法">八大排序算法</a><span>(23)</span>
</li>
<li>
<a href="http://blog.csdn.net/hguisu/article/details/7880288" title="海量数据处理算法—Bit-Map">海量数据处理算法—Bit-Map</a><span>(22)</span>
</li>
<li>
<a href="http://blog.csdn.net/hguisu/article/details/6155636" title="深入理解java异常处理机制">深入理解java异常处理机制</a><span>(22)</span>
</li>
<li>
<a href="http://blog.csdn.net/hguisu/article/details/7448528" title="PHP SOCKET编程">PHP SOCKET编程</a><span>(22)</span>
</li>
<li>
<a href="http://blog.csdn.net/hguisu/article/details/7408047" title="硬盘的读写原理">硬盘的读写原理</a><span>(21)</span>
</li>
<li>
<a href="http://blog.csdn.net/hguisu/article/details/7505909" title="设计模式（一）工厂模式Factory（创建型）">设计模式（一）工厂模式Factory（创建型）</a><span>(20)</span>
</li>
<li>
<a href="http://blog.csdn.net/hguisu/article/details/7259716" title="HDFS写入和读取流程">HDFS写入和读取流程</a><span>(19)</span>
</li>
<li>
<a href="http://blog.csdn.net/hguisu/article/details/7609483" title="UML图中类之间的关系:依赖,泛化,关联,聚合,组合,实现">UML图中类之间的关系:依赖,泛化,关联,聚合,组合,实现</a><span>(18)</span>
</li>
</ul>
</div>
<div id="homepageArticles" class="panel tracking-ad" data-mod="popu_4">
<ul class="panel_head"><span>推荐文章</span></ul>
<ul class="panel_body" id="ad_commend"><iframe id="ad_frm_2" frameborder="0" scrolling="no" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/ad.htm" style="border-width: 0px; overflow: hidden; width: 182px; height: 200px;"></iframe></ul>
</div>
<script type="text/javascript">
 new Ad(12, 'ad_commend');
</script><div id="newcomments" class="panel">
<ul class="panel_head"><span>最新评论</span></ul>
<ul class="panel_body itemlist">
    <li>
   
         <a href="http://blog.csdn.net/hguisu/article/details/7445768#comments">Linux的SOCKET编程详解</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/zaixiankaifa" class="user_name">zaixiankaifa</a>:
不得不说，写的真的很详细，当然跟经典书籍比是没有书那么详细，但是用一篇文章以简练的话语说出来通俗易懂...
    </p>
    </li>
    <li>
   
         <a href="http://blog.csdn.net/hguisu/article/details/6155636#comments">深入理解java异常处理机制</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/jly4758" class="user_name">陈丽娜</a>:
这也太详细了！
    </p>
    </li>
    <li>
   
         <a href="http://blog.csdn.net/hguisu/article/details/7465976#comments">PHP安全模式详解(PHP5.4安全模式将消失)</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/chenjiajia08" class="user_name">老陈</a>:
安全模式要消失了，为啥还强烈建议打开？
    </p>
    </li>
    <li>
   
         <a href="http://blog.csdn.net/hguisu/article/details/7465976#comments">深入理解java异常处理机制</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/u010400728" class="user_name">KingAntY</a>:
楼主态度太认真了，可惜没看完，Mark一下
    </p>
    </li>
    <li>
   
         <a href="http://blog.csdn.net/hguisu/article/details/7786014#comments">B-树和B+树的应用：数据搜索和数据库索引</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/a1bfed4a4" class="user_name">a1bfed4a4</a>:
@ahuang1900:你这个头像上的妹子是不可能懂这么深奥的问题的
    </p>
    </li>
    <li>
   
         <a href="http://blog.csdn.net/hguisu/article/details/38638183#comments">使用 libevent 和 libev 提高网络应用性能——I/O模型演进变化史</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/wusuopuBUPT" class="user_name">d4shman</a>:
总结很好！赞！
    </p>
    </li>
    <li>
   
         <a href="http://blog.csdn.net/hguisu/article/details/38638183#comments">深入理解java异常处理机制</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/yhzr_love_dandan" class="user_name">陈梦洲</a>:
写的非常棒！这是我第一次看完文章后专门登录再评论，以后应该多多说出自己的感谢，IT人的分享精神，值得...
    </p>
    </li>
    <li>
   
         <a href="http://blog.csdn.net/hguisu/article/details/7609483#comments">UML图中类之间的关系:依赖,泛化,关联,聚合,组合,实现</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/eewj" class="user_name">eewj</a>:
很好，很清晰
    </p>
    </li>
    <li>
   
         <a href="http://blog.csdn.net/hguisu/article/details/7776068#comments">八大排序算法</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/LSQ1020" class="user_name">焚稿</a>:
@ye_scofield:的确有问题，二元选择排序没有考虑到：一次选择时，最大值恰巧在队首的情况下，...
    </p>
    </li>
    <li>
   
         <a href="http://blog.csdn.net/hguisu/article/details/7453390#comments">socket阻塞与非阻塞，同步与异步、I/O模型</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/hguisu" class="user_name">真实的归宿</a>:
@asffaf:我只是读书笔记的总结。我也不是什么专家老师，没有误导任何人。如果当前线程异步处理IO...
    </p>
    </li>
</ul>
</div>
<div id="custom_column_36736957" class="panel">
<ul class="panel_head"><span>友情链接</span></ul>
<ul class="panel_body">

<a href="http://www.tuling123.com/" target="_blank">图灵机器人：聊天api的最佳选择</a>

</ul>
</div>    </div>
    <div class="clear">
    </div>
</div>

            <div class="clear">
            </div>
        </div>
        

<script type="text/javascript" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/cnick.js"></script>
<script type="text/javascript" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/newblog.min.js"></script>


<script type="text/javascript" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/showblogmedal.ashx"></script>
<script type="text/javascript">
    document.write('<script type="text/javascript" src="http://csdnimg.cn/pubfooter/js/publib_footer.js?' + Math.floor(new Date() / 120000).toString(36) + '="></' + 'script>');
</script><script type="text/javascript" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/publib_footer.js"></script><link rel="stylesheet" type="text/css" href="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/pub_footer_2012.css"><div id="pub_footerall" class="pub_footerall"><dl><dt></dt> <dd><a href="http://www.csdn.net/company/about.html" target="_blank">公司简介</a>|<a href="http://www.csdn.net/company/recruit.html" target="_blank">招贤纳士</a>|<a href="http://www.csdn.net/company/marketing.html" target="_blank">广告服务</a>|<a href="http://www.csdn.net/company/account.html" target="_blank">银行汇款帐号</a>|<a href="http://www.csdn.net/company/contact.html" target="_blank">联系方式</a>|<a href="http://www.csdn.net/company/statement.html" target="_blank">版权声明</a>|<a href="http://www.csdn.net/company/layer.html" target="_blank">法律顾问</a>|<a href="mailto:webmaster@csdn.net">问题报告</a>|<a target="_blank" href="http://www.csdn.net/friendlink.html">合作伙伴</a>|<a href="http://bbs.csdn.net/forums/Service" target="_blank">论坛反馈</a></dd><dd><a href="http://wpa.qq.com/msgrd?v=3&uin=2355263776&site=qq&menu=yes" target="_blank" class="qq">网站客服</a> <a href="http://wpa.qq.com/msgrd?v=3&uin=2251809102&site=qq&menu=yes" target="_blank" class="qq">杂志客服</a> <a href="http://e.weibo.com/csdnsupport/profile" target="_blank" class="weibo">微博客服</a> <a href="mailto:webmaster@csdn.net" class="email" title="联系邮箱">webmaster@csdn.net</a> <span class="phone" title="服务热线">400-600-2320</span></dd><dd>京&nbsp;ICP&nbsp;证&nbsp;070598&nbsp;号</dd><dd>北京创新乐知信息技术有限公司 版权所有</dd><dd>江苏乐知网络技术有限公司 提供商务支持</dd><dd>Copyright © 1999-2014, CSDN.NET, All Rights Reserved&nbsp;<a href="http://www.hd315.gov.cn/beian/view.asp?bianhao=010202001032100010" target="_blank"><img src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/gongshang_logos.gif" alt="GongshangLogo" title=""></a></dd></dl></div><div id="note1" class="csdn_note" style="display:none; position:absolute; z-index:9999; width:440px">  <span class="notice_top_arrow"><span class="inner"></span></span>  <div class="box"></div></div><div class="csdn_notice_tip" style="display: none; position: absolute; z-index: 9990; width: 170px;">  <iframe src="about:blank" frameborder="0" scrolling="no" style="z-index:-1;position:absolute;top:0;left:0;width:100%;height:100%;background:transparent"></iframe>  <div class="tip_text">您有<strong>0</strong>条新通知</div>  <a href="javascript:void 0" class="close2"></a></div><script id="noticeScript" type="text/javascript" btnid="header_notice_num" wrapid="note1" count="5" subcount="5" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/notify.js"></script>
    <script type="text/javascript" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/login.js"></script>
<script type="text/javascript">document.write("<img src=http://counter.csdn.net/pv.aspx?id=24 border=0 width=0 height=0>");</script><img src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/pv.aspx" border="0" width="0" height="0">
<script type="text/javascript" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/counter.js"></script><script type="text/javascript" charset="UTF-8" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/msg.popup.js"></script>
<script type="text/javascript" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/ad-blog.js"></script>
<script type="text/javascript" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/count.js"></script><iframe src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/logs.htm" frameborder="0" width="0" height="0"></iframe>
<script type="text/javascript">
    $(function () {
        function __get_code_toolbar(snippet_id) {
            return $("<a href='https://code.csdn.net/snippets/"
                    + snippet_id
                    + "' target='_blank' title='在CODE上查看代码片' style='text-indent:0;'><img src='https://code.csdn.net/assets/CODE_ico.png' width=12 height=12 alt='在CODE上查看代码片' style='position:relative;top:1px;left:2px;'/></a>"
                    + "<a href='https://code.csdn.net/snippets/"
                    + snippet_id
                    + "/fork' target='_blank' title='派生到我的代码片'  style='text-indent:0;'><img src='https://code.csdn.net/assets/ico_fork.svg' width=12 height=12 alt='派生到我的代码片' style='position:relative;top:2px;left:2px;'/></a>");
        }
        
        $("[code_snippet_id]").each(function () {
            __s_id = $(this).attr("code_snippet_id");
            if (__s_id != null && __s_id != "" && __s_id != 0 && parseInt(__s_id) > 70020) {
                __code_tool = __get_code_toolbar(__s_id);
                $(this).prev().find(".tools").append(__code_tool);
            }
        });
    });
</script>

    </div>
      <!--new top-->
    
    <script id="csdn-toolbar-id" btnid="header_notice_num" wrapid="note1" count="5" subcount="5" type="text/javascript" src="./八大排序算法 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET_files/toolbar.js"></script>
     <!--new top-->


<div id="tag-suggest-pop">
  <div class="relative">
    <div class="close"></div>
    <div class="content"></div>
  </div>
</div></body></html>